{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Foundation and Build Infrastructure",
        "description": "Initialize Go project structure with build tooling, dependency management, and development environment setup",
        "details": "Create go.mod with Go 1.23+, set up project directory structure following Go conventions (cmd/, internal/, pkg/, api/, proto/), configure golangci-lint, gosec, and essential dev tools. Set up Makefile for common tasks. Initialize .gitignore for Go projects. Create basic README with project overview and setup instructions.",
        "testStrategy": "Verify go mod tidy runs without errors, all linting tools execute successfully, project compiles with go build ./..., and directory structure follows Go best practices",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Go module and create standard directory structure",
            "description": "Set up go.mod file with Go 1.23+ and create the standard Go project directory layout following conventions",
            "dependencies": [],
            "details": "Create go.mod with module name and Go 1.23+ version. Create directory structure: cmd/ for application entry points, internal/ for private application code, pkg/ for public library code, api/ for API definitions, proto/ for protocol buffer files. Initialize main.go in cmd/ directory with basic application structure.",
            "status": "pending",
            "testStrategy": "Verify go mod tidy runs without errors, confirm directory structure follows Go conventions, and validate go build ./... succeeds"
          },
          {
            "id": 2,
            "title": "Configure linting and security tools (golangci-lint, gosec)",
            "description": "Set up code quality and security scanning tools with proper configuration files",
            "dependencies": [
              1
            ],
            "details": "Install and configure golangci-lint with .golangci.yml configuration file enabling key linters (govet, errcheck, staticcheck, ineffassign, misspell). Set up gosec for security vulnerability scanning with gosec.json configuration. Configure both tools to run on all Go files in the project with appropriate exclusions for generated code.",
            "status": "pending",
            "testStrategy": "Run golangci-lint and gosec on project code, verify configuration files are properly formatted, and confirm tools execute without errors on clean code"
          },
          {
            "id": 3,
            "title": "Create Makefile with common development tasks",
            "description": "Implement Makefile with essential build, test, lint, and development workflow commands",
            "dependencies": [
              2
            ],
            "details": "Create Makefile with targets for: build (compile all binaries), test (run unit tests), lint (run golangci-lint and gosec), clean (remove build artifacts), deps (download dependencies), install (install tools), and help (show available targets). Include variables for Go version, binary names, and output directories. Add phony target declarations.",
            "status": "pending",
            "testStrategy": "Execute each Makefile target successfully, verify proper dependency handling between targets, and confirm all build artifacts are created in expected locations"
          },
          {
            "id": 4,
            "title": "Initialize .gitignore and create basic project documentation",
            "description": "Set up version control exclusions and create foundational project documentation",
            "dependencies": [
              1
            ],
            "details": "Create comprehensive .gitignore file for Go projects excluding binaries, vendor/, .env files, IDE configurations, OS-specific files, and build artifacts. Create README.md with project overview, setup instructions, development workflow, and basic usage examples. Include contributing guidelines and project structure explanation.",
            "status": "pending",
            "testStrategy": "Verify .gitignore properly excludes build artifacts and sensitive files, confirm README contains all essential information for new developers, and validate markdown formatting"
          },
          {
            "id": 5,
            "title": "Validate and test complete build pipeline",
            "description": "Comprehensive testing of the entire build infrastructure and development environment",
            "dependencies": [
              3,
              4
            ],
            "details": "Execute full build pipeline validation including: go mod tidy and verify, golangci-lint run, gosec scan, make build, make test, make clean. Verify all tools are properly installed and configured. Test project structure against Go best practices. Validate that new developers can follow README instructions to set up environment successfully.",
            "status": "pending",
            "testStrategy": "Run complete build pipeline from clean state, verify all tools execute without errors, confirm project structure follows Go conventions, and validate setup instructions work on fresh environment"
          }
        ]
      },
      {
        "id": 2,
        "title": "Protocol Buffers and gRPC Service Definitions",
        "description": "Define BIAN-compliant protobuf schemas and gRPC service interfaces for FinancialAccounting, PositionKeeping, and CurrentAccount domains",
        "details": "Create proto files in api/proto/ directory following BIAN semantic models. Define messages for FinancialBookingLog, FinancialPositionLog, CurrentAccount entities. Implement gRPC services with proper request/response patterns. Add protoc-gen-go and protoc-gen-go-grpc to build pipeline. Generate Go code from protos. Include validation rules using protoc-gen-validate.",
        "testStrategy": "Verify protobuf compilation succeeds, generated Go code imports without errors, gRPC service interfaces compile, and validation rules are enforced in generated code",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "BIAN Domain Analysis and Message Schema Design",
            "description": "Analyze BIAN semantic models for FinancialAccounting, PositionKeeping, and CurrentAccount domains and design corresponding protobuf message schemas",
            "dependencies": [],
            "details": "Research BIAN specification documents for the three target domains. Map BIAN entities to protobuf messages including FinancialBookingLog, FinancialPositionLog, and CurrentAccount. Design message fields with appropriate data types, following protobuf best practices for field numbering and optional/required designations. Create comprehensive field documentation and establish naming conventions aligned with BIAN standards.",
            "status": "pending",
            "testStrategy": "Validate schema design against BIAN specification compliance, verify all required domain entities are represented, and confirm message structure supports expected use cases"
          },
          {
            "id": 2,
            "title": "gRPC Service Interface Definitions",
            "description": "Define gRPC service interfaces with proper request/response patterns for the three BIAN domains",
            "dependencies": [
              1
            ],
            "details": "Create proto service definitions for FinancialAccountingService, PositionKeepingService, and CurrentAccountService. Design RPC methods with appropriate request/response message types. Implement proper error handling patterns using gRPC status codes. Define streaming vs unary RPC patterns based on use case requirements. Include service-level documentation and method descriptions.",
            "status": "pending",
            "testStrategy": "Verify service definitions compile without errors, validate request/response message compatibility, and confirm proper gRPC method signatures"
          },
          {
            "id": 3,
            "title": "Build Pipeline Integration with Protoc Toolchain",
            "description": "Integrate protobuf compilation into build pipeline with Go code generation and required toolchain setup",
            "dependencies": [
              2
            ],
            "details": "Add protoc, protoc-gen-go, and protoc-gen-go-grpc to build dependencies. Create Makefile or build script targets for protobuf compilation. Configure output directories for generated Go code. Set up proper import paths and module structure. Integrate protobuf compilation into CI/CD pipeline. Add dependency management for protoc plugins.",
            "status": "pending",
            "testStrategy": "Verify successful protobuf compilation in build pipeline, confirm generated Go code imports correctly, and validate reproducible builds across environments"
          },
          {
            "id": 4,
            "title": "Validation Rules and Code Generation Verification",
            "description": "Implement validation rules using protoc-gen-validate and verify complete code generation pipeline",
            "dependencies": [
              3
            ],
            "details": "Add protoc-gen-validate plugin to build pipeline. Define validation rules for message fields including required fields, string patterns, numeric ranges, and custom validation logic. Generate validation code and integrate with gRPC services. Test generated Go code compilation and runtime validation behavior. Create comprehensive validation test cases.",
            "status": "pending",
            "testStrategy": "Verify validation rules are properly generated and enforced, test validation error messages and behavior, confirm generated code compiles and runs correctly"
          }
        ]
      },
      {
        "id": 3,
        "title": "Database Schema and Migration System",
        "description": "Design and implement database schema for double-entry accounting with migration support for CockroachDB/YugabyteDB",
        "details": "Create SQL schema files for accounts, transactions, ledger_entries, position_logs tables. Implement database migration system using golang-migrate or similar. Design tables to support ACID transactions, multi-currency, and audit trails. Include proper indexes for performance. Support for decimal precision financial amounts using shopspring/decimal library. Add database connection pooling and health checks.",
        "testStrategy": "Run migrations up/down successfully, verify referential integrity constraints, test decimal precision handling, validate database connection pool configuration, and confirm proper indexing with EXPLAIN ANALYZE",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Financial Schema Design with Double-Entry Constraints",
            "description": "Design and implement core database schema for double-entry accounting with proper constraints and audit trails",
            "dependencies": [],
            "details": "Create SQL schema files for accounts table (id, code, name, type, parent_id, currency), transactions table (id, reference, description, timestamp, metadata), ledger_entries table (id, transaction_id, account_id, debit_amount, credit_amount, currency, timestamp), and position_logs table (id, account_id, balance, currency, snapshot_time). Add CHECK constraints to ensure double-entry bookkeeping rules (sum of debits equals sum of credits per transaction). Include audit fields (created_at, updated_at, created_by) and soft delete support. Design hierarchical account structure with proper foreign key constraints.",
            "status": "pending",
            "testStrategy": "Verify double-entry constraints prevent unbalanced transactions, test hierarchical account relationships, validate audit trail completeness, and ensure referential integrity across all tables"
          },
          {
            "id": 2,
            "title": "Migration System Setup and Tooling",
            "description": "Implement database migration system using golang-migrate with support for CockroachDB/YugabyteDB",
            "dependencies": [
              1
            ],
            "details": "Set up golang-migrate CLI and library integration. Create migration directory structure (migrations/). Implement up/down migration files for initial schema creation. Add database driver configuration for CockroachDB and YugabyteDB. Create migration runner in Go application with proper error handling and rollback support. Include migration status tracking and version management. Add Makefile targets for common migration operations (up, down, force, version).",
            "status": "pending",
            "testStrategy": "Test migration up/down operations successfully, verify rollback functionality, validate migration status tracking, and ensure compatibility with both CockroachDB and YugabyteDB"
          },
          {
            "id": 3,
            "title": "Index Optimization and Performance Considerations",
            "description": "Design and implement database indexes for optimal query performance on financial data",
            "dependencies": [
              1
            ],
            "details": "Create composite indexes on ledger_entries (transaction_id, account_id), (account_id, timestamp) for efficient balance calculations. Add indexes on accounts (parent_id, type) for hierarchical queries. Index transactions by (timestamp, reference) for chronological and lookup queries. Create partial indexes for active records (WHERE deleted_at IS NULL). Design covering indexes for common query patterns. Add position_logs indexes on (account_id, snapshot_time) for balance history. Include index maintenance considerations for high-volume financial data.",
            "status": "pending",
            "testStrategy": "Use EXPLAIN ANALYZE to verify index usage in common queries, measure query performance improvements, test index selectivity, and validate query plans for balance calculations and reporting queries"
          },
          {
            "id": 4,
            "title": "Decimal Precision and Multi-Currency Support",
            "description": "Implement decimal precision handling using shopspring/decimal library with multi-currency support",
            "dependencies": [
              1
            ],
            "details": "Integrate shopspring/decimal library for all monetary amounts to avoid floating-point precision issues. Update schema to use DECIMAL type with appropriate precision (e.g., DECIMAL(19,4)). Create currency handling with ISO 4217 currency codes. Implement currency conversion rate storage and management. Add validation for decimal precision based on currency requirements. Create Go types and serialization/deserialization for decimal amounts in API responses. Include rounding rules for different currencies and calculation contexts.",
            "status": "pending",
            "testStrategy": "Verify decimal precision accuracy in calculations, test multi-currency arithmetic operations, validate currency conversion logic, and ensure no precision loss in database round-trips"
          },
          {
            "id": 5,
            "title": "Connection Pooling and Health Checks",
            "description": "Implement database connection pooling with health monitoring and connection management",
            "dependencies": [
              2
            ],
            "details": "Configure database connection pool using pgxpool for CockroachDB/PostgreSQL compatibility. Set appropriate pool size, max idle connections, and connection lifetime parameters. Implement database health check endpoint that verifies connection pool status and database connectivity. Add connection pool metrics (active, idle, total connections). Create graceful connection handling with proper cleanup on application shutdown. Include connection retry logic with exponential backoff. Add monitoring for connection pool exhaustion and slow queries.",
            "status": "pending",
            "testStrategy": "Test connection pool behavior under load, verify health check accuracy during database unavailability, validate connection cleanup on shutdown, and measure connection pool performance metrics"
          }
        ]
      },
      {
        "id": 4,
        "title": "Core Domain Models and Business Logic",
        "description": "Implement domain entities and business logic for financial accounting, position keeping, and current accounts following DDD principles",
        "details": "Create domain models in internal/domain/ for Account, Transaction, LedgerEntry, Position entities. Implement double-entry validation logic ensuring debits equal credits. Add support for multi-currency operations with base currency conversion. Implement account balance calculations and overdraft checking. Use value objects for Money, Currency, AccountNumber. Add domain events for transaction lifecycle.",
        "testStrategy": "Unit tests for all domain logic with >95% coverage, test double-entry validation edge cases, verify multi-currency calculations, test account balance accuracy, and validate business rule enforcement",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Domain Entity Design and Value Objects",
            "description": "Create core domain entities (Account, Transaction, LedgerEntry, Position) and value objects (Money, Currency, AccountNumber) following DDD principles",
            "dependencies": [],
            "details": "Design and implement domain entities in internal/domain/ with proper encapsulation and business invariants. Create value objects for Money (amount + currency), Currency (ISO codes), and AccountNumber (validation rules). Ensure entities are immutable where appropriate and contain no infrastructure concerns. Implement proper equality and validation methods for all value objects.",
            "status": "pending",
            "testStrategy": "Unit tests for entity creation, validation rules, value object equality, and business invariant enforcement"
          },
          {
            "id": 2,
            "title": "Double-Entry Validation Logic Implementation",
            "description": "Implement core double-entry bookkeeping validation ensuring debits equal credits for all transactions",
            "dependencies": [
              1
            ],
            "details": "Create transaction validation logic that enforces double-entry principles with automatic balancing checks. Implement LedgerEntry validation ensuring every transaction has matching debit and credit amounts. Add support for complex transactions with multiple accounts while maintaining balance integrity. Include validation for account types and allowed transaction directions.",
            "status": "pending",
            "testStrategy": "Comprehensive tests for balanced transactions, edge cases with multiple entries, validation failures for unbalanced entries, and account type constraints"
          },
          {
            "id": 3,
            "title": "Multi-Currency Operation Support",
            "description": "Add multi-currency support with base currency conversion and exchange rate handling",
            "dependencies": [
              1
            ],
            "details": "Implement currency conversion logic with configurable base currency support. Add exchange rate provider interface with real-time and historical rate support. Create currency-aware Money operations (addition, subtraction, conversion). Implement multi-currency account balances with proper rounding and precision handling. Add support for currency-specific decimal places.",
            "status": "pending",
            "testStrategy": "Test currency conversions with various exchange rates, validate multi-currency balance calculations, test rounding behavior, and verify precision handling for different currencies"
          },
          {
            "id": 4,
            "title": "Account Balance and Overdraft Logic",
            "description": "Implement account balance calculations and overdraft checking with real-time balance updates",
            "dependencies": [
              2,
              3
            ],
            "details": "Create account balance calculation engine that aggregates transactions in real-time. Implement overdraft checking with configurable limits per account type. Add support for available balance vs ledger balance calculations. Include pending transaction handling and balance holds. Implement efficient balance caching with invalidation on transaction updates.",
            "status": "pending",
            "testStrategy": "Test balance calculations with various transaction scenarios, verify overdraft limit enforcement, test pending transaction effects, and validate balance consistency under concurrent updates"
          },
          {
            "id": 5,
            "title": "Domain Events System",
            "description": "Implement domain events for transaction lifecycle and account state changes",
            "dependencies": [
              1
            ],
            "details": "Create domain event infrastructure with event sourcing capabilities. Implement events for transaction creation, posting, reversal, and account balance changes. Add event publishing mechanism with guaranteed delivery semantics. Include event replay capabilities for account reconstruction. Implement event versioning and backward compatibility handling.",
            "status": "pending",
            "testStrategy": "Test event creation and publishing, verify event ordering and replay functionality, test event versioning scenarios, and validate event-driven balance calculations"
          },
          {
            "id": 6,
            "title": "Comprehensive Unit Testing of Business Rules",
            "description": "Create extensive unit test suite covering all business rules and edge cases with >95% coverage",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Develop comprehensive test suite covering all domain logic with edge cases and error conditions. Include property-based testing for mathematical operations and business rule validation. Add performance tests for balance calculations and transaction processing. Create test fixtures for complex multi-currency scenarios. Implement mutation testing to validate test quality and ensure >95% code coverage.",
            "status": "pending",
            "testStrategy": "Achieve >95% code coverage with unit tests, property-based tests for mathematical operations, performance benchmarks for critical paths, and mutation testing to verify test effectiveness"
          }
        ]
      },
      {
        "id": 5,
        "title": "Repository Layer and Database Integration",
        "description": "Implement repository pattern for data persistence with transaction management and database abstraction",
        "details": "Create repository interfaces in internal/domain/ and implementations in internal/infrastructure/persistence/. Implement AccountRepository, TransactionRepository, LedgerRepository with CRUD operations. Add database transaction management for atomic operations. Include connection pooling, prepared statements, and proper error handling. Implement repository tests using testcontainers for integration testing against real database.",
        "testStrategy": "Integration tests using testcontainers with CockroachDB, verify transaction atomicity, test concurrent access patterns, validate database constraints enforcement, and measure query performance",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Repository Interface Design and Implementation",
            "description": "Design and implement repository interfaces in internal/domain/ and their implementations in internal/infrastructure/persistence/ following the repository pattern",
            "dependencies": [],
            "details": "Create AccountRepository, TransactionRepository, and LedgerRepository interfaces in internal/domain/. Implement concrete repository structs in internal/infrastructure/persistence/ with CRUD operations. Include proper error handling, context propagation, and domain entity mapping. Design interfaces to support future database technology changes while maintaining clean architecture principles.",
            "status": "pending",
            "testStrategy": "Unit tests for repository implementations with mock database connections, verify interface contracts are correctly implemented, test error handling scenarios"
          },
          {
            "id": 2,
            "title": "Database Transaction Management and Connection Handling",
            "description": "Implement database transaction management, connection pooling, and prepared statements for atomic operations",
            "dependencies": [
              1
            ],
            "details": "Add database transaction management wrapper functions for atomic operations across multiple repository calls. Implement connection pooling configuration with proper timeouts and limits. Create prepared statement management for frequently used queries. Add proper error handling for database connectivity issues and transaction rollbacks. Include connection health monitoring and automatic retry logic.",
            "status": "pending",
            "testStrategy": "Test transaction atomicity with rollback scenarios, verify connection pool behavior under load, validate prepared statement caching and performance improvements"
          },
          {
            "id": 3,
            "title": "Integration Testing with Testcontainers",
            "description": "Set up integration testing framework using testcontainers for real database testing scenarios",
            "dependencies": [
              1,
              2
            ],
            "details": "Configure testcontainers setup for CockroachDB integration tests. Create test fixtures and data setup utilities. Implement integration tests that verify repository operations against real database instances. Add tests for concurrent access patterns, database constraint enforcement, and transaction isolation levels. Include performance benchmarks for query execution times.",
            "status": "pending",
            "testStrategy": "Integration tests using testcontainers with CockroachDB, verify transaction atomicity, test concurrent access patterns, validate database constraints enforcement"
          },
          {
            "id": 4,
            "title": "Performance Optimization and Prepared Statements",
            "description": "Optimize database performance through prepared statements, query optimization, and performance monitoring",
            "dependencies": [
              2
            ],
            "details": "Implement prepared statement caching for frequently executed queries. Add query performance monitoring and logging for slow queries. Optimize database indexes based on query patterns. Implement batch operations for bulk data processing. Add query result caching where appropriate. Include database performance metrics collection and alerting thresholds.",
            "status": "pending",
            "testStrategy": "Performance benchmarks comparing prepared vs non-prepared statements, measure query execution times, validate caching effectiveness, test batch operation performance"
          }
        ]
      },
      {
        "id": 6,
        "title": "gRPC Service Implementation and REST Gateway",
        "description": "Implement gRPC services for BIAN domains with REST gateway for HTTP access and proper error handling",
        "details": "Create gRPC service implementations in internal/app/grpc/ using generated protobuf interfaces. Implement FinancialAccountingService, PositionKeepingService, CurrentAccountService. Add grpc-gateway for REST API exposure. Include proper error handling with gRPC status codes. Add request validation using protoc-gen-validate. Implement service-level transaction coordination.",
        "testStrategy": "gRPC client tests for all service methods, REST API tests through gateway, validate error responses and status codes, test request validation rules, and verify transaction coordination behavior",
        "priority": "medium",
        "dependencies": [
          2,
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement FinancialAccountingService gRPC Service",
            "description": "Create complete gRPC service implementation for Financial Accounting domain with all required BIAN operations",
            "dependencies": [],
            "details": "Implement FinancialAccountingService in internal/app/grpc/financial_accounting.go using generated protobuf interfaces. Include methods for CreateFinancialBookingLog, RetrieveFinancialBookingLog, UpdateFinancialBookingLog. Add proper business logic validation and database operations integration. Implement service struct with embedded database and business logic dependencies.",
            "status": "pending",
            "testStrategy": "Unit tests for all service methods, integration tests with database operations, gRPC client tests to verify proper request/response handling"
          },
          {
            "id": 2,
            "title": "Implement PositionKeeping and CurrentAccount gRPC Services",
            "description": "Create gRPC service implementations for PositionKeeping and CurrentAccount domains with full BIAN compliance",
            "dependencies": [
              1
            ],
            "details": "Implement PositionKeepingService and CurrentAccountService in internal/app/grpc/ directory. Include all CRUD operations for FinancialPositionLog and CurrentAccount entities. Add business logic for position calculations and account management. Integrate with database layer and implement proper error handling for domain-specific validation rules.",
            "status": "pending",
            "testStrategy": "Comprehensive gRPC service tests for all methods, business logic validation tests, database integration tests, and cross-service interaction verification"
          },
          {
            "id": 3,
            "title": "Implement Error Handling and gRPC Status Code Mapping",
            "description": "Create comprehensive error handling system with proper gRPC status codes and error response formatting",
            "dependencies": [
              1,
              2
            ],
            "details": "Create error handling middleware in internal/app/grpc/middleware/ to convert application errors to appropriate gRPC status codes. Implement error types for validation, business logic, and system errors. Add structured error responses with details and error codes. Include error logging and metrics collection. Map database errors, validation errors, and business rule violations to proper gRPC status codes.",
            "status": "pending",
            "testStrategy": "Error scenario tests for all service methods, verify correct status codes are returned, test error message formatting, and validate error logging behavior"
          },
          {
            "id": 4,
            "title": "Setup grpc-gateway and REST API Exposure",
            "description": "Configure grpc-gateway to expose gRPC services as REST APIs with proper HTTP method mapping and JSON serialization",
            "dependencies": [
              2,
              3
            ],
            "details": "Add grpc-gateway configuration to serve REST API alongside gRPC services. Create HTTP server in cmd/server/ to handle both protocols. Configure gateway options for proper JSON field naming and HTTP method mapping. Add CORS support and request/response logging middleware. Include OpenAPI/Swagger documentation generation from protobuf annotations.",
            "status": "pending",
            "testStrategy": "REST API integration tests for all endpoints, verify JSON request/response format, test HTTP status code mapping from gRPC errors, and validate CORS functionality"
          },
          {
            "id": 5,
            "title": "Integrate Request Validation and Service Coordination",
            "description": "Add protoc-gen-validate integration and implement service-level transaction coordination across domains",
            "dependencies": [
              4
            ],
            "details": "Integrate protoc-gen-validate for automatic request validation in gRPC interceptors. Add validation middleware to check all incoming requests against protobuf validation rules. Implement service coordination layer for cross-domain transactions using saga pattern or two-phase commit. Add transaction context propagation and rollback mechanisms for failed operations across multiple services.",
            "status": "pending",
            "testStrategy": "Validation rule tests for all request types, integration tests for cross-service transactions, test rollback scenarios, and verify transaction coordination under failure conditions"
          }
        ]
      },
      {
        "id": 7,
        "title": "Idempotency and Transaction Processing",
        "description": "Implement idempotency guarantees and safe transaction processing with Redis-based deduplication",
        "details": "Add idempotency key processing using Redis for request deduplication. Implement configurable idempotency windows and TTL management. Create middleware for automatic idempotency handling in gRPC services. Add concurrent request safety with distributed locking. Include idempotency status tracking and duplicate response caching. Support for idempotency across service restarts.",
        "testStrategy": "Test duplicate request handling, verify identical responses for duplicate keys, test concurrent duplicate requests, validate TTL expiration behavior, and ensure idempotency across service restarts",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Redis-based idempotency key system",
            "description": "Implement Redis-based idempotency key processing for request deduplication with configurable storage and validation",
            "dependencies": [],
            "details": "Create Redis client configuration and connection management. Implement idempotency key generation, validation, and storage functions. Add Redis operations for setting and retrieving idempotency entries with proper error handling. Include configuration for Redis connection parameters, key prefix patterns, and fallback behavior when Redis is unavailable.",
            "status": "pending",
            "testStrategy": "Test Redis connection establishment, verify idempotency key storage and retrieval, test error handling for Redis failures, and validate key generation consistency"
          },
          {
            "id": 2,
            "title": "Distributed locking implementation",
            "description": "Implement distributed locking mechanism using Redis to prevent concurrent processing of identical requests",
            "dependencies": [
              1
            ],
            "details": "Create distributed lock implementation using Redis SET with NX and EX options. Implement lock acquisition with timeout, renewal mechanism for long-running operations, and automatic lock release. Add deadlock prevention with configurable lock timeouts. Include proper cleanup of expired locks and handling of lock contention scenarios.",
            "status": "pending",
            "testStrategy": "Test lock acquisition and release under normal conditions, verify timeout behavior and lock renewal, test concurrent lock attempts, and validate deadlock prevention mechanisms"
          },
          {
            "id": 3,
            "title": "TTL management and cleanup",
            "description": "Implement configurable TTL management for idempotency entries with automated cleanup processes",
            "dependencies": [
              1
            ],
            "details": "Add configurable TTL settings for idempotency keys based on operation type and business requirements. Implement background cleanup processes for expired entries. Create TTL extension mechanisms for long-running operations. Add monitoring and alerting for TTL-related issues and cleanup performance metrics.",
            "status": "pending",
            "testStrategy": "Test TTL expiration behavior, verify cleanup process effectiveness, test TTL extension for long operations, and validate monitoring metrics accuracy"
          },
          {
            "id": 4,
            "title": "Concurrent request handling",
            "description": "Implement safe concurrent request processing with proper synchronization and duplicate response caching",
            "dependencies": [
              1,
              2
            ],
            "details": "Create middleware for gRPC services to handle idempotency automatically. Implement response caching for completed idempotent operations. Add proper synchronization for concurrent requests with same idempotency key. Include status tracking for in-progress, completed, and failed operations. Handle race conditions and ensure consistent response delivery.",
            "status": "pending",
            "testStrategy": "Test concurrent duplicate requests processing, verify identical responses for duplicate keys, test response caching effectiveness, and validate synchronization under high concurrency"
          },
          {
            "id": 5,
            "title": "Service restart resilience and testing",
            "description": "Ensure idempotency state persistence across service restarts with comprehensive testing suite",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement persistent state management in Redis for idempotency across service restarts. Add graceful shutdown procedures to preserve in-flight idempotency state. Create comprehensive test suite covering restart scenarios, state recovery, and edge cases. Include load testing for idempotency performance under high throughput and integration tests with other system components.",
            "status": "pending",
            "testStrategy": "Test state persistence across service restarts, verify recovery of in-flight operations, perform load testing under various restart scenarios, and validate integration with overall system resilience"
          }
        ]
      },
      {
        "id": 8,
        "title": "Event Streaming and Kafka Integration",
        "description": "Implement transaction event streaming to Kafka with at-least-once delivery and protobuf serialization aligned with ADR-0004",
        "status": "pending",
        "dependencies": [
          4,
          6
        ],
        "priority": "medium",
        "details": "Add Kafka producer integration using sarama or kafka-go (NO confluent-kafka-go). Implement event publishing for all transaction state changes using direct protobuf serialization (NO Schema Registry). Create event schemas using protobuf definitions in api/proto/events/. Add producer configuration for reliability (acks=all, retries, idempotence). Implement dead letter queue handling for failed events. Include event ordering guarantees per account using partitioning by account ID. Schema compatibility validated via 'buf breaking' in CI/CD. Database (CockroachDB) is source of truth; Kafka provides internal coordination only.",
        "testStrategy": "Integration tests with Kafka testcontainers (no Schema Registry container), verify direct protobuf serialization/deserialization, test producer failure handling, validate event ordering per partition, test backward compatibility with buf breaking, and confirm dead letter queue processing",
        "subtasks": [
          {
            "id": 1,
            "title": "Kafka Producer Setup with Standard Go Client",
            "description": "Set up Kafka producer using sarama or kafka-go with reliability configuration for at-least-once delivery",
            "dependencies": [],
            "details": "Install and configure sarama or kafka-go library (NOT confluent-kafka-go). Set up producer configuration with acks=all, retries, enable.idempotence=true, and proper timeout settings. Create connection management with health checks and graceful shutdown. Add configuration loading from environment variables or config files. Reference ADR-0004 Event Schema Evolution Strategy for implementation guidance.",
            "status": "pending",
            "testStrategy": "Unit tests for producer configuration, integration tests with Kafka testcontainers, verify connection establishment and graceful shutdown without Schema Registry dependencies"
          },
          {
            "id": 2,
            "title": "Protobuf Event Schema Design and Direct Serialization",
            "description": "Create protobuf event schemas in api/proto/events/ with direct proto.Marshal/Unmarshal serialization",
            "dependencies": [
              1
            ],
            "details": "Design event schemas for transaction creation, updates, completion, and error states in api/proto/events/ directory. Implement direct protobuf serialization/deserialization using proto.Marshal/Unmarshal (NO Schema Registry client). Define common event envelope with metadata (timestamp, correlation ID, event type). Add backward/forward compatibility validation via 'buf breaking' command. Follow ADR-0004 patterns for event evolution using optional fields and new event types for BIAN behavior qualifiers.",
            "status": "pending",
            "testStrategy": "Schema validation tests, direct protobuf serialization/deserialization round-trip tests, compatibility tests with 'buf breaking', verify no Schema Registry integration"
          },
          {
            "id": 3,
            "title": "Event Ordering and Partitioning Strategy",
            "description": "Implement event ordering guarantees using account-based partitioning",
            "dependencies": [
              1
            ],
            "details": "Implement partitioning strategy using account ID as partition key to ensure ordering per account. Create partition key generation logic. Add event sequence numbering within partitions. Handle partition rebalancing scenarios. Implement ordering validation and monitoring.",
            "status": "pending",
            "testStrategy": "Test event ordering within partitions, verify partition key generation, test multiple concurrent accounts, validate ordering during rebalancing scenarios"
          },
          {
            "id": 4,
            "title": "Dead Letter Queue Implementation",
            "description": "Implement dead letter queue handling for failed event publishing",
            "dependencies": [
              2,
              3
            ],
            "details": "Create dead letter queue topic configuration. Implement retry logic with exponential backoff. Add failure classification (retryable vs non-retryable errors). Create DLQ consumer for manual intervention. Add monitoring and alerting for DLQ events. Implement event replay functionality from DLQ.",
            "status": "pending",
            "testStrategy": "Test failure scenarios and DLQ routing, verify retry logic with exponential backoff, test DLQ consumer functionality, validate event replay from DLQ"
          },
          {
            "id": 5,
            "title": "Integration Testing and Schema Evolution Validation",
            "description": "Comprehensive integration testing with protobuf-native schema evolution validation",
            "dependencies": [
              4
            ],
            "details": "Create end-to-end integration tests using Kafka testcontainers (no Schema Registry container). Test producer failure scenarios and recovery. Verify at-least-once delivery guarantees. Test direct protobuf serialization performance. Add 'buf breaking' validation in CI/CD pipeline. Create chaos engineering tests for reliability validation. Validate BIAN event evolution patterns from ADR-0004.",
            "status": "pending",
            "testStrategy": "End-to-end integration tests with protobuf serialization, buf breaking compatibility validation, chaos engineering scenarios, performance benchmarks, verify delivery guarantees under various failure conditions"
          }
        ]
      },
      {
        "id": 9,
        "title": "Observability and Health Monitoring",
        "description": "Implement comprehensive observability with metrics, tracing, logging, and health endpoints",
        "details": "Add OpenTelemetry instrumentation for distributed tracing across all services. Implement Prometheus metrics for business and system metrics (transaction rates, latencies, error rates). Create structured JSON logging with correlation IDs using zerolog or similar. Add health check endpoints (/health/live, /health/ready) with dependency checking. Include custom metrics for financial operations and BIAN compliance tracking.",
        "testStrategy": "Verify metrics collection and export to Prometheus, validate trace propagation across service boundaries, test health endpoint responses under various dependency states, and confirm log correlation across requests",
        "priority": "medium",
        "dependencies": [
          6,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "OpenTelemetry Tracing Setup and Instrumentation",
            "description": "Set up OpenTelemetry SDK with distributed tracing across all gRPC services and database operations",
            "dependencies": [],
            "details": "Initialize OpenTelemetry tracer provider with OTLP exporter configuration. Add tracing middleware for gRPC services using otelgrpc interceptors. Instrument database operations with sqlboiler hooks or manual spans. Configure trace sampling and resource attributes. Set up trace context propagation across service boundaries. Include custom spans for business operations like transaction processing and account updates.",
            "status": "pending",
            "testStrategy": "Verify trace spans are created for all gRPC calls, validate trace context propagation between services, test trace export to OTLP collector, and confirm custom business operation spans appear correctly"
          },
          {
            "id": 2,
            "title": "Prometheus Metrics Implementation",
            "description": "Implement Prometheus metrics collection for system and business metrics with proper labeling",
            "dependencies": [
              1
            ],
            "details": "Set up Prometheus client library with metrics registry. Create custom metrics for transaction rates, processing latencies, error rates, and account balances. Add gRPC metrics using grpc-prometheus interceptors. Implement business metrics for financial operations like transaction volumes, currency distributions, and BIAN compliance events. Configure metrics endpoint at /metrics with proper HTTP middleware. Include histogram metrics for latency tracking and counter metrics for throughput.",
            "status": "pending",
            "testStrategy": "Validate metrics are exposed at /metrics endpoint, verify custom business metrics increment correctly, test histogram bucket configurations for latency metrics, and confirm gRPC metrics are collected automatically"
          },
          {
            "id": 3,
            "title": "Structured Logging with Correlation IDs",
            "description": "Implement structured JSON logging with correlation ID tracking across all service operations",
            "dependencies": [],
            "details": "Set up zerolog or similar structured logging library with JSON output format. Implement correlation ID middleware for gRPC services to generate and propagate request IDs. Add logging interceptors that include trace context and correlation IDs in all log entries. Create standardized log fields for financial operations including transaction IDs, account references, and operation types. Configure log levels and output destinations with proper log rotation.",
            "status": "pending",
            "testStrategy": "Verify correlation IDs are present in all log entries for a request, validate JSON log format structure, test log propagation across service calls, and confirm sensitive financial data is properly masked in logs"
          },
          {
            "id": 4,
            "title": "Health Check Endpoints and Dependency Monitoring",
            "description": "Create comprehensive health check endpoints with dependency status monitoring and readiness probes",
            "dependencies": [
              2
            ],
            "details": "Implement /health/live and /health/ready endpoints following Kubernetes probe patterns. Create health checkers for database connectivity, external service dependencies, and internal service readiness. Add circuit breaker pattern for dependency health checks. Include detailed health status with dependency-specific error messages. Implement graceful shutdown handling that updates health status. Expose health metrics through Prometheus for monitoring dashboard integration.",
            "status": "pending",
            "testStrategy": "Test health endpoints return correct HTTP status codes, verify dependency health checks detect actual failures, validate readiness probe behavior during startup and shutdown, and confirm health metrics are properly exposed"
          }
        ]
      },
      {
        "id": 10,
        "title": "Authentication, Authorization, and Security",
        "description": "Implement OAuth 2.0/OIDC authentication with RBAC authorization and security hardening",
        "details": "Add OAuth 2.0/OpenID Connect authentication using go-oidc library. Implement role-based access control (RBAC) with service domain permissions. Add JWT token validation middleware for gRPC and REST. Include API key authentication for service accounts. Implement TLS 1.3 for all communications. Add rate limiting and request size limits. Include security headers and CORS configuration.",
        "testStrategy": "Test OAuth flow integration, verify RBAC permission enforcement, validate JWT token processing, test API key authentication, confirm TLS configuration, and verify rate limiting behavior",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "OAuth 2.0/OIDC Integration Setup",
            "description": "Set up OAuth 2.0 and OpenID Connect authentication flow using go-oidc library with provider configuration and token validation",
            "dependencies": [],
            "details": "Install and configure go-oidc library, set up OIDC provider discovery, implement authorization code flow with PKCE, configure client credentials and redirect URIs, add token introspection endpoint, and implement logout functionality with proper session cleanup",
            "status": "pending",
            "testStrategy": "Test OAuth flow end-to-end with mock OIDC provider, verify token validation and introspection, test authorization code exchange, and validate logout behavior"
          },
          {
            "id": 2,
            "title": "RBAC System Implementation",
            "description": "Implement role-based access control system with service domain permissions and user role management",
            "dependencies": [
              1
            ],
            "details": "Design RBAC data model with roles, permissions, and service domains, create permission checking middleware, implement role assignment and management APIs, add service-specific permission validation, and create admin interfaces for role management",
            "status": "pending",
            "testStrategy": "Test role assignment and permission enforcement, verify service domain isolation, test permission inheritance, and validate admin role management operations"
          },
          {
            "id": 3,
            "title": "JWT and API Key Middleware",
            "description": "Create JWT token validation middleware for gRPC and REST services plus API key authentication for service accounts",
            "dependencies": [
              1
            ],
            "details": "Implement JWT validation middleware with signature verification and claims extraction, add gRPC interceptors for token validation, create REST middleware for JWT processing, implement API key authentication system with key rotation, and add service account management for API keys",
            "status": "pending",
            "testStrategy": "Test JWT validation with valid and invalid tokens, verify gRPC interceptor functionality, test API key authentication flow, and validate service account access patterns"
          },
          {
            "id": 4,
            "title": "TLS Configuration and Security Headers",
            "description": "Configure TLS 1.3 for all communications and implement security headers with CORS configuration",
            "dependencies": [],
            "details": "Configure TLS 1.3 certificates and cipher suites, implement automatic certificate rotation, add security headers middleware (HSTS, CSP, X-Frame-Options), configure CORS policies for web clients, and implement certificate validation for service-to-service communication",
            "status": "pending",
            "testStrategy": "Test TLS 1.3 handshake and cipher negotiation, verify security headers in responses, test CORS preflight requests, and validate certificate rotation behavior"
          },
          {
            "id": 5,
            "title": "Rate Limiting and Security Testing",
            "description": "Implement rate limiting with request size limits and conduct comprehensive security testing of authentication system",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement sliding window rate limiting per user and API key, add request size validation middleware, create rate limit bypass for admin users, implement distributed rate limiting with Redis, and conduct security penetration testing of all authentication flows",
            "status": "pending",
            "testStrategy": "Test rate limiting under various load conditions, verify request size limit enforcement, test rate limit bypass functionality, and conduct security testing including token replay attacks and privilege escalation attempts"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-24T16:56:52.202Z",
      "updated": "2025-10-24T16:56:52.202Z",
      "description": "Tasks for master context"
    }
  },
  "1-infra": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Go Module and Project Structure",
        "description": "Set up the Go module with proper directory structure and initial configuration files",
        "details": "Initialize go.mod with 'github.com/bjcoombs/meridian' module name using Go 1.23+. Create basic project structure with cmd/, internal/, pkg/, and api/ directories. Update .gitignore for Go-specific patterns (vendor/, dist/, *.test, coverage.out). Create .env.example with placeholder environment variables.",
        "testStrategy": "Verify go.mod syntax with 'go mod tidy', check that 'go version' shows 1.23+, validate directory structure exists and follows Go project layout standards",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:32:54.517Z"
      },
      {
        "id": "2",
        "title": "Create Makefile with Essential Build Targets",
        "description": "Implement comprehensive Makefile with all required build, test, and deployment targets",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Successfully implemented comprehensive Makefile with all required targets including build, test, lint, clean, proto, docker, deploy-local. Added additional utility targets: fmt, tidy, deps, install, coverage, help. Version injection via ldflags is properly configured with VERSION, COMMIT, and BUILD_DATE variables. All targets have been tested and verified working. Created minimal main.go at cmd/meridian/main.go that displays version information, and main_test.go with version variable tests. Build artifacts are placed in dist/ directory, coverage reports in coverage/ directory. Includes proper dependency management and tool installation automation. Ready for production use.",
        "testStrategy": "All make targets have been executed and verified: 'make help' displays comprehensive target list, 'make build' successfully compiles to dist/meridian with version injection, 'make test' runs with coverage output, 'make fmt' formats code, 'make tidy' manages Go modules, 'make coverage' generates HTML reports. Created test file that validates version variables are properly injected during build process.",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:07:57.061Z"
      },
      {
        "id": "3",
        "title": "Configure golangci-lint and Code Quality Tools",
        "description": "Set up golangci-lint configuration with strict rules and pre-commit hooks",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "✅ COMPLETED: Comprehensive golangci-lint configuration and pre-commit hooks successfully implemented and tested.\n\nImplemented Configuration:\n- Complete .golangci.yml with 25+ production-grade linters including:\n  • Core linters: govet, errcheck, staticcheck, unused, ineffassign, misspell, gocyclo\n  • Quality linters: revive, goconst, gocognit, unconvert, unparam, nakedret, prealloc\n  • Error handling: err113, wrapcheck, errorlint, nilerr, contextcheck\n  • Resource checks: sqlclosecheck, rowserrcheck, noctx\n  • Formatters: gofmt, goimports, gofumpt\n- Complexity limits: gocyclo (15), gocognit (20)\n- Smart exclusions for test files (_test.go), generated files (.pb.go), and mocks (mock_*.go)\n- Special handling for cmd/ directory allowing longer functions and unchecked flag parsing\n\nPre-commit Hooks:\n- .githooks/pre-commit: Validates staged Go files with gofmt and golangci-lint\n- .githooks/install.sh: Easy installation script using 'git config core.hooksPath .githooks'\n- Both scripts executable with proper error handling and user-friendly output\n\nIntegration:\n- Compatible with existing Makefile 'make lint' target\n- Configured for golangci-lint v2.5.0\n- Timeout: 5m with parallel runners enabled\n\nFiles created in worktree/1-3-golangci-lint/:\n- .golangci.yml (175 lines)\n- .githooks/pre-commit (52 lines)\n- .githooks/install.sh (21 lines)\n\nPR: https://github.com/bjcoombs/meridian/pull/11\nCommit: dc0eb24\nStatus: Ready for review and merge",
        "testStrategy": "✅ COMPLETED: All testing successfully performed:\n\n1. golangci-lint Configuration Testing:\n   - Ran 'golangci-lint run' on sample Go code\n   - Successfully detected multiple issue types:\n     • Dynamic errors and unused functions\n     • Package comment issues\n     • Formatting inconsistencies\n     • Error handling violations\n   - Verified all 25+ linters are active and reporting correctly\n\n2. Pre-commit Hook Testing:\n   - Installed hooks using .githooks/install.sh\n   - Tested git commit with poorly formatted code - correctly blocked\n   - Tested git commit with clean code - allowed through\n   - Verified error messages are clear and actionable\n   - Confirmed '--no-verify' bypass works when needed\n\n3. Makefile Integration Testing:\n   - 'make lint' passes on clean code\n   - 'make lint' fails appropriately on code with issues\n   - 'make install' properly installs golangci-lint\n   - All error messages reference correct make targets\n\n4. Performance Testing:\n   - golangci-lint runs complete within 5m timeout\n   - Pre-commit hooks execute quickly on staged files only\n   - Compatible with parallel runners for CI environments\n\nAll test scenarios passed successfully. Configuration is production-ready.",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:08:03.686Z"
      },
      {
        "id": "4",
        "title": "Create Multi-Stage Dockerfile for Production Images",
        "description": "Build optimized Docker images using multi-stage builds with security scanning",
        "details": "Create Dockerfile with stages: 1) Build stage using golang:1.23-alpine with CGO_ENABLED=0 for static binaries, 2) Runtime stage using gcr.io/distroless/static for minimal attack surface. Copy only necessary files, set non-root user, add health check endpoint. Target image size <50MB. Include .dockerignore to exclude unnecessary files.",
        "testStrategy": "Build Docker image and verify size <50MB, scan with trivy for vulnerabilities, test container starts and health check responds, verify binary runs without external dependencies",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:31:39.741Z"
      },
      {
        "id": "5",
        "title": "Create Kubernetes Base Manifests",
        "description": "Design Kubernetes manifests for deployments, services, and configuration management",
        "details": "Create deployments/k8s/base/ with: Deployment manifest with proper resource limits (CPU: 100m-500m, Memory: 128Mi-512Mi), liveness/readiness probes on /health endpoint, rolling update strategy. Service manifest with ClusterIP type and proper port mapping. ConfigMap for application configuration. Use kustomization.yaml for base configuration. Include proper labels and selectors.",
        "testStrategy": "Validate YAML syntax with kubectl dry-run, test deployment to local cluster, verify services are accessible, confirm ConfigMap values are injected correctly",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:37:39.825Z"
      },
      {
        "id": "6",
        "title": "Set up Kustomize Overlays for Environments",
        "description": "Create environment-specific configurations using Kustomize overlays",
        "details": "Create overlays for dev/, staging/, production/ in deployments/k8s/overlays/. Dev: increased log levels, resource limits relaxed, single replica. Staging: production-like settings, 2 replicas, monitoring enabled. Production: strict resource limits, 3+ replicas, security policies, network policies. Each overlay includes kustomization.yaml with resource patches and ConfigMap generators.",
        "testStrategy": "Build each overlay with 'kustomize build', verify environment-specific values are correctly applied, test deployment of each overlay to separate namespaces",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Configure Tilt for Local Development Environment",
        "description": "Create Tiltfile orchestrating local Kubernetes development with live reload",
        "details": "Create Tiltfile that deploys: CockroachDB single-node cluster with persistent volume, Redis with default configuration, Kafka+Zookeeper using bitnami charts. Configure live_update for Go services with go build on file changes. Set up port forwarding for debugging. Include resource dependencies and health checks. Target <5 second rebuild time.",
        "testStrategy": "Run 'tilt up' and verify all services start successfully, test live reload by modifying Go code, verify port-forwards work for database connections, measure rebuild time on code changes",
        "priority": "high",
        "dependencies": [
          "5",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-27T10:15:44.837Z"
      },
      {
        "id": "8",
        "title": "Create GitHub Actions CI Pipeline",
        "description": "Implement comprehensive CI/CD workflows for testing, building, and deployment",
        "details": "Create .github/workflows/: test.yml (checkout, setup Go 1.23, run tests with coverage, upload to codecov), lint.yml (golangci-lint, security scan with gosec), build.yml (build Docker images, push to registry with git SHA tags), deploy.yml (deploy to staging/prod with health checks). Include required status checks configuration.",
        "testStrategy": "Test each workflow with sample PR, verify test results are reported, confirm Docker images are built and tagged correctly, validate deployment workflow with staging environment",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "review",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:38:25.738Z"
      },
      {
        "id": "9",
        "title": "Create Development Setup Documentation",
        "description": "Write comprehensive README and setup guides for new developers",
        "details": "Create README.md with: project overview, architecture diagram, quick start guide (clone → tilt up in <5 minutes), development workflow, make targets explanation, troubleshooting section. Include setup script for installing dependencies (Docker, kubectl, Tilt, golangci-lint). Document environment variables and configuration options.",
        "testStrategy": "Have fresh developer follow README from clean machine, measure setup time, verify all make targets work as documented, test troubleshooting section resolves common issues",
        "priority": "medium",
        "dependencies": [
          "7",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-27T10:15:42.847Z"
      },
      {
        "id": "10",
        "title": "Implement Security Scanning and Production Hardening",
        "description": "Add security scanning, vulnerability detection, and production security configurations",
        "details": "Integrate trivy scanning in CI for container vulnerabilities, add gosec for Go security analysis, configure RBAC for Kubernetes deployments, implement network policies for production, set up secret management references (not actual secrets), add security contexts with non-root users and read-only filesystems.",
        "testStrategy": "Run security scans and verify zero critical vulnerabilities, test RBAC restrictions, verify network policies block unauthorized traffic, confirm containers run as non-root with read-only filesystem",
        "priority": "medium",
        "dependencies": [
          "8",
          "6"
        ],
        "status": "review",
        "subtasks": [],
        "updatedAt": "2025-10-26T08:43:20.649Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-27T10:15:44.838Z",
      "taskCount": 10,
      "completedCount": 8,
      "tags": [
        "1-infra"
      ]
    }
  },
  "2-api-contracts": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Protocol Buffers Development Environment",
        "description": "Configure protobuf toolchain with buf, protoc-gen-go, and validation plugins for BIAN API development",
        "details": "Install and configure buf CLI tool with buf.yaml configuration for proto validation and breaking change detection. Set up protoc-gen-go, protoc-gen-go-grpc, and protoc-gen-validate plugins. Create buf.gen.yaml for Go code generation. Configure proto workspace with module structure for api/proto/ directory. Add Makefile targets for proto compilation and validation.",
        "testStrategy": "Verify buf lint and breaking change detection work correctly, test protoc compilation succeeds with no errors, validate Go code generation produces expected files, confirm protoc-gen-validate rules are enforced",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:33:18.381Z"
      },
      {
        "id": 2,
        "title": "Define Common Proto Types and Enums",
        "description": "Create reusable common types for Money, Currency, AccountType, and other BIAN-standard values",
        "details": "Create api/proto/common/v1/types.proto with Money message (currency string, amount int64, decimal_places int32), AccountType enum (DEBIT, CREDIT, VOSTRO, NOSTRO, CURRENT, SAVINGS), PostingDirection enum (DEBIT, CREDIT), and standard Timestamp message. Add validation rules using protoc-gen-validate for ISO-4217 currency codes, positive amounts, and valid decimal places. Include error.proto for standardized error responses.",
        "testStrategy": "Validate Money type handles various currencies correctly, test enum values conform to BIAN standards, verify validation rules prevent invalid data, confirm proto compilation generates correct Go types",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:43:38.725Z"
      },
      {
        "id": 3,
        "title": "Implement FinancialAccounting Proto Definitions",
        "description": "Create FinancialBookingLog and LedgerPosting protobuf messages with complete BIAN service interface",
        "details": "Design api/proto/financial_accounting/v1/financial_accounting.proto with FinancialBookingLog message (financial_account_type, product_service_reference, business_unit_reference, chart_of_accounts_rules, base_currency, status), LedgerPosting message (posting_direction, posting_amount, value_date, posting_result). Create gRPC service FinancialAccountingService with methods: InitiateFinancialBookingLog, UpdateFinancialBookingLog, RetrieveFinancialBookingLog, CaptureLedgerPosting, RetrieveLedgerPosting. Add comprehensive request/response message pairs for each method.",
        "testStrategy": "Verify all BIAN FinancialAccounting operations are represented, test proto compilation generates expected gRPC service interfaces, validate message fields align with BIAN specification, confirm request/response patterns are consistent",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement PositionKeeping Proto Definitions",
        "description": "Create FinancialPositionLog protobuf messages and gRPC service for transaction logging and reconciliation",
        "details": "Design api/proto/position_keeping/v1/position_keeping.proto with FinancialPositionLog message (transaction_log_entries, transaction_lineage, audit_trail, status_tracking). Create PositionKeepingService with methods for transaction log operations: InitiateFinancialPositionLog, UpdateFinancialPositionLog, RetrieveFinancialPositionLog. Add support for bulk transaction import and status tracking. Include transaction lineage and audit trail fields for compliance.",
        "testStrategy": "Validate transaction log operations compile correctly, test bulk transaction support message structures, verify audit trail and lineage fields are properly defined, confirm service methods align with BIAN PositionKeeping specification",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "review",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:10:54.899Z"
      },
      {
        "id": 5,
        "title": "Implement CurrentAccount Proto Definitions",
        "description": "Create CurrentAccountFacility protobuf messages and gRPC service for account management operations",
        "details": "Design api/proto/current_account/v1/current_account.proto with CurrentAccountFacility message (account_identification, account_status enum [ACTIVE, FROZEN, CLOSED], balance_tracking, overdraft_limits, transaction_history). Create CurrentAccountService with methods: InitiateCurrentAccountFacility, UpdateCurrentAccountFacility, RetrieveCurrentAccountFacility, ExecuteDebitTransaction, ExecuteCreditTransaction, RetrieveAccountBalance. Add account status management and transaction history tracking.",
        "testStrategy": "Test account status enum values are correct, verify debit/credit operations are properly defined, validate balance retrieval message structure, confirm overdraft limit handling is included, test transaction history support",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Add Comprehensive Validation Rules",
        "description": "Implement protoc-gen-validate rules for all proto messages to ensure data integrity and BIAN compliance",
        "details": "Add validation rules to all proto messages using protoc-gen-validate annotations. Required field validation for all request messages, string format validation for ISO currency codes and UUIDs, numeric range validation for amounts (> 0), enum validation to prevent UNSPECIFIED values in requests. Add custom validation for account numbers, reference formats, and business-specific rules. Include string length limits and pattern matching for regulatory compliance.",
        "testStrategy": "Generate validation code and test with invalid inputs, verify required field validation prevents empty requests, test string format validation catches invalid currencies, confirm numeric validation prevents negative amounts, validate enum constraints work correctly",
        "priority": "medium",
        "dependencies": [
          "3",
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Configure Build Pipeline Integration",
        "description": "Integrate protobuf compilation into build pipeline with Go code generation and version management",
        "details": "Update Makefile with 'proto' target that runs buf generate and protoc commands. Configure buf.gen.yaml to generate Go code to internal/gen/proto/ directory. Add proto compilation to CI/CD pipeline with buf breaking change detection. Set up proto version management with v1, v2 namespace support. Include dependency management for protoc plugins and ensure reproducible builds across environments.",
        "testStrategy": "Run 'make proto' and verify Go code is generated correctly, test buf breaking change detection with intentional breaking changes, validate CI pipeline fails on proto errors, confirm generated code imports work in Go modules",
        "priority": "medium",
        "dependencies": [
          "1",
          "6"
        ],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2025-10-25T11:46:27.170Z"
      },
      {
        "id": 8,
        "title": "Generate OpenAPI Specifications",
        "description": "Configure protoc-gen-openapiv2 to generate OpenAPI/Swagger specs from protobuf definitions",
        "details": "Add protoc-gen-openapiv2 plugin to buf.gen.yaml configuration. Configure OpenAPI generation with proper HTTP method mapping using google.api.http annotations in proto files. Generate swagger.json files for each service (financial_accounting, position_keeping, current_account). Include API documentation with examples, error responses, and security requirements. Add OpenAPI validation and documentation hosting setup.",
        "testStrategy": "Generate OpenAPI specs and validate with swagger-codegen, verify HTTP method mappings are correct, test API documentation includes all endpoints, validate OpenAPI specs pass validation tools, confirm examples are generated correctly",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create Proto Documentation and Examples",
        "description": "Write comprehensive documentation for all proto definitions with usage examples and BIAN compliance notes",
        "details": "Create api/proto/README.md explaining proto structure, build process, and versioning strategy. Add inline documentation to all proto files with godoc-style comments. Create examples/ directory with sample requests and responses for each service method. Document BIAN compliance mapping and field explanations. Include migration guide for proto changes and breaking change policy.",
        "testStrategy": "Verify README instructions allow new developers to understand and use protos, test that all proto comments are clear and complete, validate examples compile and work with generated code, confirm BIAN mapping documentation is accurate",
        "priority": "low",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Proto Testing and Quality Assurance",
        "description": "Create comprehensive testing framework for protobuf definitions with linting and validation verification",
        "details": "Set up buf lint with strict rules for proto style and consistency. Create test suite that validates all generated Go code compiles and imports correctly. Add integration tests that verify protoc-gen-validate rules work as expected. Implement breaking change detection in CI pipeline. Create performance tests for proto serialization/deserialization. Add automated testing for OpenAPI spec generation and validation.",
        "testStrategy": "Run buf lint and verify zero style violations, execute all proto tests in CI pipeline, test breaking change detection with sample changes, validate protoc-gen-validate rules with invalid inputs, measure proto serialization performance against benchmarks",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-25T11:46:27.171Z",
      "taskCount": 10,
      "completedCount": 2,
      "tags": [
        "2-api-contracts"
      ],
      "created": "2025-10-25T18:24:27.194Z",
      "description": "Tasks for 2-api-contracts context",
      "updated": "2025-10-25T18:24:27.194Z"
    }
  },
  "3-platform": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Go Module Initialization",
        "description": "Initialize Go module, set up project structure, and configure basic tooling for the platform services",
        "details": "Create go.mod file with module name 'meridian', set up directory structure for internal/platform/ and migrations/, configure .gitignore for Go projects, add basic Makefile for common tasks, and set up CI/CD configuration files. Initialize Go module with latest stable Go version (1.21+).",
        "testStrategy": "Verify go.mod is created correctly, directory structure matches PRD specifications, and basic build/test commands work without errors",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Layer Implementation",
        "description": "Implement database connection pooling, health checks, and core DB interface for CockroachDB/YugabyteDB",
        "details": "Create internal/platform/db/db.go with DB interface, implement connection pooling with pgxpool (50 max connections), add context-aware query execution with timeouts, implement graceful shutdown with connection draining, add transaction management helpers, and connection health checks with automatic retry logic.",
        "testStrategy": "Unit tests with testcontainers using PostgreSQL container, integration tests for connection pooling under load, test graceful shutdown scenarios, verify timeout handling and health check accuracy",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Migration System Setup",
        "description": "Implement database migration system using Atlas with GORM integration for automatic migration generation from Go structs",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Install Atlas CLI tool (https://atlasgo.io/), create atlas.hcl configuration file with GORM integration, define Go domain models in internal/domain/models.go with GORM tags, use Atlas to auto-generate SQL migrations from Go struct changes, implement 'atlas migrate diff' for automatic migration generation, 'atlas migrate lint' for safety checks, 'atlas migrate test' for validation, and 'atlas migrate apply' for deployment. Maintains Flyway-style immutability with atlas.sum checksums. Benefits include automatic migration generation from Go structs (no manual SQL), schema linting to catch destructive changes, migration testing for validation, type safety with Go structs as source of truth, and ability to write manual SQL migrations when needed.",
        "testStrategy": "Test Atlas CLI installation and configuration, verify GORM model parsing and migration generation with 'atlas migrate diff', test schema linting with 'atlas migrate lint' to catch dangerous changes, validate migrations with 'atlas migrate test' on test database, test migration application with 'atlas migrate apply', verify atlas.sum checksum validation, test rollback scenarios, and integration with CI/CD for automated validation",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Atlas CLI tool",
            "description": "Install Atlas CLI tool using the official installation script and verify installation",
            "dependencies": [],
            "details": "Download and install Atlas CLI using 'curl -sSf https://atlasgo.sh | sh', verify installation with 'atlas version', ensure Atlas is available in PATH for CI/CD integration",
            "status": "pending",
            "testStrategy": "Verify Atlas CLI installation with 'atlas version' command, test basic Atlas commands work correctly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create atlas.hcl configuration file",
            "description": "Set up Atlas configuration file with GORM integration and environment-specific settings",
            "dependencies": [
              1
            ],
            "details": "Create atlas.hcl in project root with GORM source configuration pointing to internal/domain, set up local and production environments, configure dev database for schema diffing, set migration directory to file://migrations, enable destructive change linting with error flag",
            "status": "pending",
            "testStrategy": "Validate atlas.hcl syntax with 'atlas env test', verify GORM integration configuration works correctly",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define Go domain models with GORM tags",
            "description": "Create internal/domain/models.go with GORM-tagged structs for financial booking logs",
            "dependencies": [
              2
            ],
            "details": "Create internal/domain/ directory structure, implement FinancialBookingLog struct with GORM tags for UUID primary key, unique indexes, JSON fields, timestamps, and proper database constraints. Include AmountData embedded struct for JSONB amount block. Follow ADR-0003 schema design with control_record_id, booking_purpose, value_date, currencies, and audit fields",
            "status": "pending",
            "testStrategy": "Test GORM model compilation, verify struct tags are valid GORM syntax, test Atlas can parse Go structs correctly with 'atlas schema inspect'",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Generate initial migration from Go structs",
            "description": "Use Atlas to generate the first migration file from the defined Go domain models",
            "dependencies": [
              3
            ],
            "details": "Run 'atlas migrate diff initial_schema --env gorm --to gorm://internal/domain' to generate initial migration SQL from Go structs, verify generated migration includes financial_booking_log table with all fields, indexes, and constraints, validate migration syntax and Atlas checksum generation",
            "status": "pending",
            "testStrategy": "Verify migration file is generated in migrations/ directory, test generated SQL syntax is valid PostgreSQL, verify atlas.sum checksum file is created",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test migration workflow with lint and test commands",
            "description": "Validate the migration workflow using Atlas lint and test commands",
            "dependencies": [
              4
            ],
            "details": "Run 'atlas migrate lint --env gorm --latest 1' to validate migration safety, test 'atlas migrate test --env gorm --dev-url docker://postgres/15/test' for migration validation, verify destructive change detection works correctly, test migration rollback scenarios",
            "status": "pending",
            "testStrategy": "Verify lint command catches dangerous changes, test migration test command validates successfully on test database, confirm migration can be applied and rolled back",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integrate Atlas with CI/CD pipeline",
            "description": "Add Atlas migration validation to GitHub Actions workflow",
            "dependencies": [
              5
            ],
            "details": "Create .github/workflows/migrate.yml with Atlas installation, migration linting on pull requests affecting internal/domain/ or migrations/, automated testing with test database, and production deployment on main branch. Include Atlas CLI installation, lint validation, test execution, and migration application steps",
            "status": "pending",
            "testStrategy": "Test GitHub Actions workflow triggers correctly, verify Atlas commands run in CI environment, test migration validation fails appropriately for dangerous changes",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-25T18:31:46.471Z"
      },
      {
        "id": 4,
        "title": "Event Streaming (Kafka) Framework",
        "description": "Implement Kafka producer/consumer framework with direct protobuf serialization following ADR-0004 Event Schema Evolution Strategy (no Schema Registry)",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Create internal/platform/events/kafka.go with EventPublisher and EventConsumer interfaces using direct protobuf Marshal/Unmarshal for serialization. Implement producer with idempotent configuration and partitioning by entity ID. Add consumer framework with consumer group management and offset commit strategies. Implement dead letter queue for failed messages. All events use protobuf schemas from api/proto/events/ with buf breaking validation for backward compatibility in CI/CD. No Confluent Schema Registry dependencies - Kafka is internal-only coordination, database is source of truth.",
        "testStrategy": "Integration tests using Kafka testcontainer (no Schema Registry container), test direct protobuf serialization/deserialization with proto.Marshal/Unmarshal, verify consumer handles unknown fields gracefully for backward compatibility, test idempotency and partitioning, verify consumer group behavior and offset management, test dead letter queue functionality under failure scenarios, test backward compatibility with buf breaking checks in CI/CD",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove Confluent Dependencies and Install Standard Kafka Client",
            "description": "Replace Confluent Schema Registry dependencies with standard Kafka Go client and direct protobuf serialization",
            "dependencies": [],
            "details": "Remove github.com/confluentinc/confluent-kafka-go/v2/schemaregistry and protobuf serde packages from consideration. Install github.com/IBM/sarama or github.com/segmentio/kafka-go for Kafka client. Update go.mod with Kafka client dependencies. Verify compatibility with existing protobuf setup from meridian-main/api/proto/ for direct proto.Marshal/Unmarshal usage. No Schema Registry client libraries needed.",
            "status": "pending",
            "testStrategy": "Test dependency installation and verify no conflicts with existing proto generation, test basic Kafka client connectivity",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Direct Protobuf Serialization Framework",
            "description": "Implement direct protobuf serialization/deserialization without Schema Registry",
            "dependencies": [
              1
            ],
            "details": "Create internal/platform/events/serialization.go with protobuf marshaling utilities. Implement type-safe serialization using proto.Marshal() and proto.Unmarshal() directly. Create topic-to-message-type registry for consumer deserialization. Add message envelope with event metadata (event_id, occurred_at, correlation_id). Support backward compatibility by ignoring unknown fields (protobuf default behavior).",
            "status": "pending",
            "testStrategy": "Unit tests for serialization/deserialization, test backward compatibility with unknown fields, verify type safety",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement EventPublisher with Direct Protobuf",
            "description": "Create Kafka producer with direct protobuf serialization and no Schema Registry",
            "dependencies": [
              2
            ],
            "details": "Implement EventPublisher interface in internal/platform/events/kafka.go. Use proto.Marshal() for direct serialization without Schema Registry client. Configure idempotent producer (acks=all, enable.idempotence=true). Implement partitioning by entity ID for message ordering. Add message envelope with metadata (event_id, occurred_at, correlation_id, event_type). No schema registration needed - compile-time validation via buf breaking in CI/CD.",
            "status": "pending",
            "testStrategy": "Test direct protobuf serialization on publish, verify idempotent configuration, test partitioning strategy, test message envelope creation",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement EventConsumer with Direct Protobuf",
            "description": "Create Kafka consumer with direct protobuf deserialization and type-safe message handling",
            "dependencies": [
              2
            ],
            "details": "Implement EventConsumer interface with proto.Unmarshal() for direct deserialization. Add consumer group management with configurable group IDs. Implement offset commit strategies (auto-commit vs manual). Create topic-to-message-type mapping for type-safe deserialization. Support graceful handling of unknown fields for backward compatibility. No Schema Registry client needed.",
            "status": "pending",
            "testStrategy": "Test direct protobuf deserialization on consume, verify consumer group behavior, test offset management, test unknown field handling",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Dead Letter Queue Support",
            "description": "Implement dead letter queue functionality for failed message processing without Schema Registry",
            "dependencies": [
              3,
              4
            ],
            "details": "Create dead letter queue publisher for messages that fail processing or deserialization. Configure separate Kafka topic for DLQ with appropriate retention. Add message headers for original topic, error details, and retry count. Implement configurable retry logic before sending to DLQ. Use direct protobuf serialization for DLQ messages. Add monitoring for DLQ message rates.",
            "status": "pending",
            "testStrategy": "Test DLQ functionality under various failure scenarios including protobuf deserialization failures, verify message headers and metadata, test retry logic",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Event Schema Definitions",
            "description": "Define protobuf event schemas following ADR-0004 structure in api/proto/events/ for direct protobuf usage",
            "dependencies": [],
            "details": "Create api/proto/events/ directory structure mirroring BIAN domains (financial_accounting, position_keeping, current_account). Define example event schemas with proper event_id, occurred_at, correlation_id, and domain-specific fields following ADR-0004 patterns. Follow immutable event patterns with backward-compatible evolution. Update buf.gen.yaml to generate Go code for event schemas. Events will use direct proto.Marshal/Unmarshal without Schema Registry.",
            "status": "pending",
            "testStrategy": "Test protobuf code generation, verify direct serialization with generated code, test event immutability patterns, verify buf lint passes",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Add buf breaking CI/CD Integration for Schema Evolution",
            "description": "Implement buf breaking checks in CI/CD pipeline for schema compatibility validation without Schema Registry",
            "dependencies": [
              6
            ],
            "details": "Create CI/CD pipeline integration using 'buf breaking --against main' for compatibility validation. Replace Schema Registry compatibility checking with compile-time validation. Add pre-commit hooks or CI checks to validate schema changes. Create documentation for schema evolution best practices using protobuf native versioning from ADR-0004. No runtime schema registration needed - all validation at compile/build time.",
            "status": "pending",
            "testStrategy": "Test buf breaking validation in CI/CD pipeline, verify compatibility checking blocks breaking changes, test documentation generation from schemas",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 5,
        "title": "OpenTelemetry Tracing Implementation",
        "description": "Set up distributed tracing with OpenTelemetry and OTLP exporter",
        "details": "Create internal/platform/observability/tracing.go, initialize tracer with OTLP exporter, implement gRPC interceptors for automatic span creation, add context propagation across service boundaries, configure trace sampling, and add helper functions for manual span creation with proper attributes.",
        "testStrategy": "Unit tests for tracer initialization and span creation, integration tests verifying trace propagation across service calls, test sampling configuration, validate OTLP export functionality",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Prometheus Metrics and Structured Logging",
        "description": "Implement Prometheus metrics collection and structured JSON logging with correlation IDs",
        "details": "Create internal/platform/observability/metrics.go with standard metrics (http_requests_total, http_request_duration_seconds, grpc_server_handled_total, db_query_duration_seconds, kafka_messages_published_total), implement metrics endpoint, create logging.go with JSON-formatted logs, correlation ID support, context-aware logging with trace/span IDs, and PII redaction utilities.",
        "testStrategy": "Test metrics registration and collection, verify metrics endpoint functionality, test structured logging output format, validate correlation ID propagation, test PII redaction functionality",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "review",
        "subtasks": [],
        "updatedAt": "2025-10-26T08:36:55.705Z"
      },
      {
        "id": 7,
        "title": "JWT Authentication and OAuth Integration",
        "description": "Implement JWT token validation middleware and OAuth 2.0 integration for external identity providers",
        "details": "Create internal/platform/auth/jwt.go with JWT validation using RS256, implement public key rotation support, add claims extraction (user ID, roles, scopes), create gRPC interceptor for authentication, implement oauth.go with support for Auth0/Okta, add token introspection endpoint, and client credentials flow for service accounts.",
        "testStrategy": "Unit tests for JWT validation with test keys, test public key rotation scenarios, integration tests with mock OAuth provider, test gRPC interceptor functionality, validate token introspection endpoint",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "RBAC Authorization Framework",
        "description": "Implement role-based access control with predefined roles and permission checking middleware",
        "details": "Create internal/platform/auth/rbac.go with role definitions (admin, operator, auditor, service), implement permission checking middleware, add service-level authorization rules, create role assignment and validation functions, integrate with JWT claims for role extraction, and add authorization helpers for different resource types.",
        "testStrategy": "Unit tests for role validation and permission checking, test role assignment scenarios, integration tests with JWT authentication, test authorization middleware with different roles, validate access control for various resources",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Redis-based Idempotency Layer",
        "description": "Implement idempotency checking with Redis storage, distributed locking, and TTL-based expiration",
        "details": "Create internal/platform/idempotency/idempotency.go with IdempotencyChecker interface, implement Redis-based storage with key format {service}:{operation}:{user_provided_key}, add distributed locking using Redis SETNX, implement TTL-based expiration (24h default), store operation results for duplicate request responses, and add automatic cleanup of expired keys.",
        "testStrategy": "Integration tests using Redis testcontainer, test idempotency key storage and retrieval, verify distributed locking behavior under concurrent access, test TTL expiration and cleanup, validate duplicate request handling",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Health Check System Implementation",
        "description": "Implement comprehensive health check endpoints for liveness, readiness, and dependency status monitoring",
        "details": "Create internal/platform/health/health.go with liveness probe (/health/live), readiness probe (/health/ready) checking database, Kafka, and Redis connectivity, detailed dependency status endpoint (/health/status) with response time metrics, implement health check middleware, add configurable timeouts for dependency checks, and JSON response formatting.",
        "testStrategy": "Unit tests for individual health check components, integration tests with all dependencies (DB, Kafka, Redis), test health check endpoints under various failure scenarios, verify Kubernetes probe compatibility, test response time metrics accuracy",
        "priority": "medium",
        "dependencies": [
          "2",
          "4",
          "9"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-26T08:36:55.706Z",
      "taskCount": 10,
      "completedCount": 0,
      "tags": [
        "3-platform"
      ],
      "created": "2025-10-26T08:37:37.675Z",
      "description": "Tasks for 3-platform context",
      "updated": "2025-10-26T08:37:37.675Z"
    }
  },
  "4-financial-accounting": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Go Module Initialization",
        "description": "Initialize Go module structure with necessary dependencies for the financial accounting service",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Successfully implemented Go module structure for the Meridian financial accounting service. Created go.mod file with module name github.com/bjcoombs/meridian and added all required dependencies: github.com/google/uuid v1.6.0, github.com/shopspring/decimal v1.4.0, github.com/lib/pq v1.10.9 for PostgreSQL support. Established complete project structure with internal/financial-accounting/ directory containing domain/, repository/, and service/ packages. Added comprehensive package documentation for each layer following BIAN standards. Created tools.go file to track dependencies and ensure they remain in go.mod. Verified all builds compile successfully with 'go build ./...' and dependencies validate with 'go mod tidy'. PR #26 completed implementation and merged successfully.",
        "testStrategy": "Verified go.mod file validity with 'go mod tidy' command. Confirmed project compiles successfully with 'go build ./...' command. Validated directory structure matches PRD specification with internal/financial-accounting/ containing domain/, repository/, and service/ packages. Tested dependency resolution for all required packages: github.com/google/uuid, github.com/shopspring/decimal, github.com/lib/pq. Confirmed tools.go pattern correctly tracks dependencies.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create go.mod file with module declaration",
            "description": "Initialize go.mod with github.com/bjcoombs/meridian module name and Go 1.25.3",
            "dependencies": [],
            "details": "Create go.mod file in project root with proper module declaration and Go version specification",
            "status": "done",
            "testStrategy": "Verify go.mod file is created and valid with 'go mod tidy'",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add required dependencies to go.mod",
            "description": "Add core dependencies: github.com/google/uuid, github.com/shopspring/decimal, github.com/lib/pq",
            "dependencies": [
              1
            ],
            "details": "Add all financial accounting service dependencies including UUID generation, decimal arithmetic, and PostgreSQL driver",
            "status": "done",
            "testStrategy": "Verify dependencies are properly resolved and available in go.mod",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create internal/financial-accounting directory structure",
            "description": "Set up package structure with domain/, repository/, and service/ subdirectories",
            "dependencies": [
              1
            ],
            "details": "Create complete directory hierarchy for financial accounting service following clean architecture patterns",
            "status": "done",
            "testStrategy": "Confirm all directories exist and contain appropriate package documentation",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add package documentation files",
            "description": "Create doc.go files in each package with BIAN-compliant documentation",
            "dependencies": [
              3
            ],
            "details": "Document each package layer with appropriate Go package documentation following BIAN standards",
            "status": "done",
            "testStrategy": "Verify package documentation is complete and follows Go conventions",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create tools.go for dependency tracking",
            "description": "Implement tools.go pattern to ensure dependencies remain in go.mod",
            "dependencies": [
              2
            ],
            "details": "Create tools.go with build constraints to track development dependencies that may not be directly referenced in production code yet",
            "status": "done",
            "testStrategy": "Confirm tools.go correctly imports dependencies and maintains them in go.mod",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-26T09:14:23.990Z"
      },
      {
        "id": 2,
        "title": "Domain Model Implementation - Core Types",
        "description": "Implement unified domain model using Go structs as single source of truth with GORM and proto tags following ADR-0004",
        "status": "review",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Implement unified schema management approach where Go structs in internal/domain/models.go serve as the single source of truth for both database schema (via GORM tags) and Protobuf event schemas (via proto tags). This follows ADR-0004 unified schema management.\n\nPR #27 COMPLETED: Core domain value objects implemented in internal/financial-accounting/domain/:\n- Money value object with decimal.Decimal precision and currency validation\n- Currency enum with 7 ISO 4217 codes (GBP, USD, EUR, JPY, CHF, CAD, AUD)\n- AccountType enum with 6 types (DEBIT, CREDIT, VOSTRO, NOSTRO, CURRENT, SAVINGS)\n- PostingDirection enum (DEBIT/CREDIT) with Opposite() method\n- TransactionStatus enum with 5 lifecycle states and IsFinal() predicate\n\nAll types include validation, serialization, and comprehensive test coverage.\n\nNEXT PHASE: Implement FinancialBookingLog aggregate with dual GORM and proto tags:\n- ID field with `gorm:\"type:uuid;primary_key\"` and `proto:\"id,1\"`\n- ControlRecordID with `gorm:\"uniqueIndex;not null\"` and `proto:\"control_record_id,2\"`\n- Amount (Money type), Currency, ValueDate fields with both tag types\n- CreatedAt, Version for audit trail\n\nIntegration requirements:\n- Atlas integration for automatic database schema generation\n- Custom protogen tool for Protobuf schema generation\n- Both schemas synchronized automatically from Go structs",
        "testStrategy": "Unit tests for each type validation and enum string representations completed (6/6 test suites passing). Next: Test FinancialBookingLog struct field validation with both valid and invalid values. Test Atlas migration generation from GORM tags. Test custom protogen tool schema generation from proto tags. Integration tests verifying database operations with generated schema. Test enum parsing and serialization for both database and Protobuf contexts.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create core domain value objects and enums",
            "description": "Implement foundational domain types with validation and serialization",
            "dependencies": [],
            "details": "COMPLETED: Implemented core domain value objects in internal/financial-accounting/domain/:\n\n1. Money value object:\n   - Uses shopspring/decimal for precise arithmetic\n   - Currency validation in constructor\n   - Add/Subtract operations with currency matching\n   - IsZero, IsPositive, IsNegative predicates\n   - String representation with 2 decimal places\n\n2. Currency enum:\n   - 7 ISO 4217 currency codes (GBP, USD, EUR, JPY, CHF, CAD, AUD)\n   - IsValid() validation method\n   - ParseCurrency() for string conversion\n\n3. AccountType enum:\n   - 6 account types: DEBIT, CREDIT, VOSTRO, NOSTRO, CURRENT, SAVINGS\n   - IsValid() validation method\n\n4. PostingDirection enum:\n   - DEBIT/CREDIT with validation\n   - Opposite() method for double-entry logic\n\n5. TransactionStatus enum:\n   - 5 lifecycle states: PENDING, POSTED, FAILED, CANCELLED, REVERSED\n   - IsFinal() predicate for terminal states\n\nAll types include comprehensive unit tests with 100% coverage.",
            "status": "done",
            "testStrategy": "Unit tests completed for all value objects and enums. Tests cover validation, edge cases, arithmetic operations, and state predicates. All 6 test suites passing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement FinancialBookingLog aggregate with dual tags",
            "description": "Create the core aggregate struct with GORM and proto tags for unified schema management",
            "dependencies": [
              1
            ],
            "details": "Create FinancialBookingLog aggregate in internal/financial-accounting/domain/models.go implementing unified schema approach from ADR-0004. Build on completed value objects (Money, Currency, AccountType, PostingDirection, TransactionStatus) to define the main aggregate:\n\n- ID field: `gorm:\"type:uuid;primary_key\" proto:\"id,1\"`\n- ControlRecordID: `gorm:\"uniqueIndex;not null\" proto:\"control_record_id,2\"`\n- Amount field using Money type with both tag types\n- Currency, ValueDate, Status fields with dual tagging\n- CreatedAt, UpdatedAt, Version for audit trail\n- Proper struct validation methods\n\nThis aggregate becomes the source of truth for both Atlas database schema generation and custom protogen Protobuf schema generation.",
            "status": "pending",
            "testStrategy": "Unit tests for struct field validation, enum value validation, and proper tag parsing. Test that struct can be used with both GORM operations and proto serialization. Validate Money integration and audit field behavior.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Atlas configuration for GORM schema generation",
            "description": "Configure Atlas to generate database migrations from Go struct GORM tags",
            "dependencies": [
              2
            ],
            "details": "Set up Atlas configuration to read GORM tags from FinancialBookingLog aggregate and generate PostgreSQL migrations automatically. Create atlas.hcl configuration file with GORM environment pointing to the domain models. Test that `atlas migrate diff` generates correct SQL DDL from the Go struct definitions. This ensures database schema stays synchronized with Go domain model changes.",
            "status": "pending",
            "testStrategy": "Integration tests running atlas migrate diff and verifying generated SQL contains correct table definitions, indexes, and constraints matching the GORM tags. Test migration application to PostgreSQL test database.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop custom protogen tool for Protobuf schema generation",
            "description": "Create custom code generator that reads proto tags and generates Protobuf event schemas",
            "dependencies": [
              2
            ],
            "details": "Implement tools/protogen/main.go that parses Go structs and extracts proto tag information to generate Protobuf event schemas. Tool should:\n\n- Parse AST of FinancialBookingLog and related domain types\n- Extract proto tag field numbers and names\n- Generate .proto files in api/proto/events/\n- Handle Go type to Protobuf type mapping (time.Time -> google.protobuf.Timestamp, uuid.UUID -> string, Money -> custom message)\n- Add event metadata (event_id, occurred_at) automatically\n- Integrate with existing Currency, AccountType, PostingDirection, TransactionStatus enums\n\nThis ensures Protobuf schemas stay synchronized with Go domain model changes.",
            "status": "pending",
            "testStrategy": "Unit tests for AST parsing, proto tag extraction, and type mapping. Integration tests generating actual .proto files and validating they compile with protoc. Test generated Protobuf schemas can serialize/deserialize Go structs correctly with Money and enum types.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-26T09:18:15.623Z"
      },
      {
        "id": 3,
        "title": "FinancialBookingLog Aggregate Root Implementation",
        "description": "Implement the FinancialBookingLog aggregate root with all business methods and invariants",
        "details": "Create domain/financial_booking_log.go with struct containing ID (UUID), FinancialAccountType, ProductServiceRef, BusinessUnitRef, ChartOfAccountsRulesRef, BaseCurrency, Status, CreatedAt, UpdatedAt. Implement methods: Suspend(), Resume(), Close(), CanAcceptPosting(). Add validation for status transitions (active→suspended→active OR active→closed). Ensure base currency is valid ISO-4217 code.",
        "testStrategy": "Unit tests for all state transitions. Test invariant violations (e.g., invalid currency, illegal status changes). Property-based testing for status transition sequences. Mock UUID generation for deterministic tests.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "LedgerPosting Entity Implementation",
        "description": "Implement LedgerPosting entity with validation and business rules",
        "details": "Create domain/ledger_posting.go with struct containing ID, BookingLogID, PostingDirection, AccountCode, PostingAmount (Money), PostingValueDate, PostingResult, IdempotencyKey, CreatedAt. Implement Validate() method checking: amount > 0, currency compatibility, value date within 1 year bounds, idempotency key uniqueness per booking log. Add helper methods for currency conversion validation.",
        "testStrategy": "Unit tests for all validation rules. Test edge cases: zero amounts, future/past dates beyond limits, currency mismatches. Test idempotency key uniqueness constraints. Validate posting direction enum handling.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Double-Entry Transaction Validation Logic",
        "description": "Implement transaction-level validation ensuring double-entry accounting principles",
        "details": "Create domain/transaction.go with Transaction struct containing slice of LedgerPosting and IdempotencyKey. Implement Validate() method: ensure minimum 2 postings, at least 1 debit and 1 credit, sum of debits equals sum of credits using decimal arithmetic. Add ValidateDoubleEntry function for posting slice validation. Include multi-currency support with exchange rate validation. Handle decimal precision for money calculations.",
        "testStrategy": "Unit tests for balanced/unbalanced transactions. Property-based testing with random posting combinations. Test multi-currency scenarios with exchange rates. Test decimal precision edge cases to ensure no rounding errors.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Repository Interface and Database Schema",
        "description": "Define repository interfaces and implement PostgreSQL database schema",
        "details": "Create repository/interfaces.go with FinancialBookingLogRepository and LedgerPostingRepository interfaces as specified in PRD. Implement database schema with migrations: financial_booking_logs table with UUID primary key, enum constraints, timestamps; ledger_postings table with foreign key to booking logs, amount stored as bigint with decimal places, unique constraint on (booking_log_id, idempotency_key). Add indexes for performance: booking_log_id, idempotency_key, posting_value_date.",
        "testStrategy": "Test repository interfaces compile correctly. Verify database schema with migration tools. Test constraint enforcement (foreign keys, check constraints, unique indexes). Performance testing for index effectiveness on large datasets.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "PostgreSQL Repository Implementation",
        "description": "Implement concrete repository classes for PostgreSQL persistence",
        "details": "Create repository/postgres/ package with concrete implementations of repository interfaces. Implement FinancialBookingLogRepository: Create, FindByID, Update, List with filtering. Implement LedgerPostingRepository: CreatePostings (batch insert), FindByID, FindByBookingLogID, FindByIdempotencyKey. Use database/sql with prepared statements, proper error handling, and transaction support. Include connection pooling configuration.",
        "testStrategy": "Integration tests using testcontainers for PostgreSQL. Test all CRUD operations, batch inserts, concurrent access scenarios. Test connection pooling under load. Verify transaction rollback on errors. Test repository error handling and mapping.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "gRPC Protocol Buffer Definitions",
        "description": "Create protobuf definitions for financial accounting service API following ADR-0004 Event Schema Evolution Strategy",
        "status": "pending",
        "dependencies": [
          "4"
        ],
        "priority": "medium",
        "details": "Following ADR-0004 Event Schema Evolution Strategy (PR #23 merged), implement protobuf definitions using manual schema definition approach with buf tooling for validation:\n\n1. Manual Event Schema Definition:\n   - Create api/proto/events/financial_accounting/v1/events.proto\n   - Define event messages following BIAN patterns: FinancialBookingLogInitiated, FinancialBookingLogClosed, LedgerPostingCaptured\n   - Include standard event metadata (event_id, occurred_at, correlation_id, causation_id)\n   - Use common types from meridian/common/v1/types.proto for consistency\n   - Follow protobuf v3 syntax with proper package declarations and imports\n\n2. Manual gRPC Service Definition:\n   - Create api/proto/financial_accounting/v1/financial_accounting.proto\n   - Define FinancialAccountingService with RPCs: InitiateFinancialBookingLog, UpdateFinancialBookingLog, ControlFinancialBookingLog, RetrieveFinancialBookingLog, CaptureLedgerPosting, RetrieveLedgerPosting\n   - Request/response messages using common types from meridian/common/v1/\n   - Include field validation using buf.build/bufbuild/protovalidate\n   - Error handling with meridian/common/v1/error.proto\n\n3. Buf Tooling Integration:\n   - Use existing buf.gen.yaml configuration to compile protobuf files\n   - Run 'buf generate' to create Go code with paths=source_relative\n   - Use 'buf lint' for schema validation and style compliance\n   - Use 'buf breaking --against main' in CI/CD for compatibility validation\n   - Generated Go files placed in api/proto/ subdirectories matching protobuf package structure\n\n4. Event Evolution Strategy:\n   - Pattern 1: Add optional fields to existing messages (validated by buf breaking)\n   - Pattern 2: New BIAN behavior qualifiers = new event types\n   - One topic per event type: financial-booking-log-initiated, ledger-posting-captured\n   - No Schema Registry - buf breaking provides compile-time validation\n   - 7-day retention policy for internal coordination events\n\nThis approach aligns with ADR-0004's decision to use protobuf native versioning without Schema Registry, focusing on compile-time validation and BIAN-aligned semantic event types.",
        "testStrategy": "Validate .proto files pass buf lint for style and correctness. Test buf generate creates valid Go code that compiles. Verify buf breaking catches incompatible changes when run against main branch. Test gRPC service definitions compile and generate proper Go server/client code. Verify event message serialization/deserialization works correctly. Test field validation annotations function properly. Validate generated code integrates with existing project structure and common types. Test event publishing and consumption with test Kafka cluster to ensure end-to-end functionality.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create event schema definitions in api/proto/events/financial_accounting/v1/",
            "description": "Manually define protobuf event schemas following BIAN patterns and ADR-0004 guidelines",
            "dependencies": [],
            "details": "Create api/proto/events/financial_accounting/v1/events.proto with:\n- Protobuf v3 syntax and proper package declaration (meridian.events.financial_accounting.v1)\n- Import statements for google/protobuf/timestamp.proto and meridian/common/v1/types.proto\n- Event messages following BIAN behavior qualifiers:\n  * FinancialBookingLogInitiated (maps to BIAN Initiate operation)\n  * FinancialBookingLogClosed (maps to BIAN Terminate operation)\n  * LedgerPostingCaptured (maps to BIAN Capture operation)\n- Standard event metadata fields for all events:\n  * event_id (string, field 1)\n  * occurred_at (google.protobuf.Timestamp, field 2)\n  * correlation_id (string, field 3)\n  * causation_id (string, field 4)\n- Business data fields using common types:\n  * booking_log_id (string, UUID format)\n  * amounts using meridian.common.v1.MoneyAmount\n  * currencies using meridian.common.v1.Currency enum\n  * account types using meridian.common.v1.AccountType enum\n- Field validation using buf.build/bufbuild/protovalidate\n- Go package option: github.com/bjcoombs/meridian/api/proto/events/financial_accounting/v1;financialaccountingeventsv1",
            "status": "pending",
            "testStrategy": "Verify .proto file passes buf lint validation. Test protoc compilation succeeds. Validate all imports resolve correctly. Check field numbers are sequential and unique. Test buf generate creates valid Go code without compilation errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create gRPC service definitions in api/proto/financial_accounting/v1/",
            "description": "Define gRPC service contracts for financial accounting operations",
            "dependencies": [],
            "details": "Create api/proto/financial_accounting/v1/financial_accounting.proto with:\n- Protobuf v3 syntax and package declaration (meridian.financial_accounting.v1)\n- Import statements for meridian/common/v1/types.proto, meridian/common/v1/error.proto, google/protobuf/timestamp.proto\n- FinancialAccountingService definition with RPCs:\n  * InitiateFinancialBookingLog(InitiateFinancialBookingLogRequest) returns (InitiateFinancialBookingLogResponse)\n  * UpdateFinancialBookingLog(UpdateFinancialBookingLogRequest) returns (UpdateFinancialBookingLogResponse)\n  * ControlFinancialBookingLog(ControlFinancialBookingLogRequest) returns (ControlFinancialBookingLogResponse)\n  * RetrieveFinancialBookingLog(RetrieveFinancialBookingLogRequest) returns (RetrieveFinancialBookingLogResponse)\n  * CaptureLedgerPosting(CaptureLedgerPostingRequest) returns (CaptureLedgerPostingResponse)\n  * RetrieveLedgerPosting(RetrieveLedgerPostingRequest) returns (RetrieveLedgerPostingResponse)\n- Request/response message types for each RPC using common types\n- Field validation with buf.build/bufbuild/protovalidate\n- Error handling integration with meridian/common/v1/error.proto\n- Go package option: github.com/bjcoombs/meridian/api/proto/financial_accounting/v1;financialaccountingv1\n- Follow resource-oriented API design patterns",
            "status": "pending",
            "testStrategy": "Validate protobuf compilation with buf generate. Test generated Go gRPC server/client code compiles without errors. Verify service method signatures are correct. Test field validation rules work as expected. Validate error message integration functions properly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Compile protobuf schemas using buf generate",
            "description": "Generate Go code from protobuf definitions using existing buf.gen.yaml configuration",
            "dependencies": [
              1,
              2
            ],
            "details": "Execute buf generate to compile protobuf schemas:\n- Use existing buf.gen.yaml configuration with paths=source_relative\n- Generate Go code for both event schemas and gRPC service definitions\n- Ensure generated files are placed in correct api/proto/ subdirectories\n- Generated Go packages:\n  * api/proto/events/financial_accounting/v1/ (event messages)\n  * api/proto/financial_accounting/v1/ (gRPC service and types)\n- Verify integration with existing buf plugins:\n  * buf.build/protocolbuffers/go (core Go protobuf)\n  * buf.build/grpc/go (gRPC Go code generation)\n  * buf.build/bufbuild/validate-go (field validation)\n- Run 'buf generate' command to create all Go code\n- Verify generated code compiles with 'go build ./...'",
            "status": "pending",
            "testStrategy": "Run buf generate and verify all .proto files compile successfully. Test generated Go code imports correctly and compiles without errors. Verify no compilation conflicts with existing generated code. Check generated files are placed in expected directories matching protobuf package structure.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Validate protobuf schemas with buf lint and breaking change detection",
            "description": "Set up buf tooling validation for schema compliance and compatibility",
            "dependencies": [
              3
            ],
            "details": "Implement buf tooling validation workflow:\n- Run 'buf lint' to validate schema style and correctness\n- Configure buf.yaml to include all protobuf directories if not already present\n- Test 'buf breaking --against main' for compatibility validation\n- Ensure no breaking changes are introduced to existing schemas\n- Validate field validation annotations work correctly\n- Test protobuf style compliance (naming conventions, field numbering)\n- Document validation workflow for future schema changes\n- Verify integration with CI/CD pipeline for automated validation\n- Test error handling for schema compatibility violations",
            "status": "pending",
            "testStrategy": "Run buf lint and verify all schemas pass validation. Test buf breaking with intentional breaking changes to confirm detection works. Verify field validation annotations generate correct validation code. Test schema compilation in CI/CD environment. Validate error messages are clear and actionable.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test event message serialization and gRPC integration",
            "description": "Verify generated protobuf code works correctly for serialization and gRPC communication",
            "dependencies": [
              4
            ],
            "details": "Create comprehensive tests for protobuf integration:\n- Unit tests for event message creation and serialization/deserialization\n- Test event metadata fields are correctly populated (event_id, occurred_at, correlation_id, causation_id)\n- Verify common types integration (MoneyAmount, Currency, AccountType)\n- Test field validation rules trigger correctly for invalid data\n- Create mock gRPC server and client tests for service methods\n- Test request/response message handling for all RPCs\n- Verify error handling integration with meridian/common/v1/error.proto\n- Performance tests for large message serialization\n- Test backward compatibility with protobuf optional field handling\n- Integration tests with test Kafka cluster for event publishing/consuming\n- Document test patterns for future event types",
            "status": "pending",
            "testStrategy": "Unit tests for all event message types with valid and invalid data. Test gRPC service method invocation with generated client/server code. Verify field validation works correctly with various input scenarios. Test protobuf serialization performance and correctness. Integration tests with Kafka for end-to-end event flow.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Document protobuf schema structure and evolution guidelines",
            "description": "Create documentation for schema management following ADR-0004 principles",
            "dependencies": [
              5
            ],
            "details": "Create comprehensive documentation for protobuf schema management:\n- Document schema directory structure (api/proto/events/ vs api/proto/services/)\n- Create event catalog in docs/events/event-catalog.md listing all event types\n- Document BIAN behavior qualifier to event type mapping\n- Guidelines for when to add optional fields vs create new event types\n- buf tooling workflow documentation (lint, generate, breaking)\n- Schema evolution patterns with examples following ADR-0004\n- Testing patterns for new schemas and changes\n- Integration with CI/CD pipeline documentation\n- Troubleshooting guide for common protobuf issues\n- Reference examples for future financial accounting events\n- Guidelines for Kafka topic naming and retention policies\n- Update api/proto/README.md with financial accounting service examples",
            "status": "pending",
            "testStrategy": "Review documentation for accuracy and completeness. Test documented workflows work as described. Verify examples compile and run correctly. Validate documentation helps new developers understand schema management approach.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9,
        "title": "gRPC Service Implementation",
        "description": "Implement the financial accounting gRPC service with all business operations",
        "details": "Create service/financial_accounting_service.go implementing the gRPC service interface. Include financialAccountingService struct with bookingLogRepo, postingRepo, eventPublisher, idempotencyChecker dependencies. Implement CaptureLedgerPosting with full workflow: idempotency check, double-entry validation, chart of accounts validation, transactional posting storage, domain event publishing. Implement all other service methods according to BIAN specification. Add proper error handling and status codes.",
        "testStrategy": "Unit tests for each service method with mocked dependencies. Integration tests with real repositories and database. Test idempotency behavior with duplicate requests. Test concurrent posting scenarios. Verify domain events are published correctly.",
        "priority": "medium",
        "dependencies": [
          "7",
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Comprehensive Testing and Documentation",
        "description": "Complete test coverage, performance validation, and integration testing",
        "details": "Achieve >95% test coverage for domain logic. Implement property-based testing for double-entry invariants using testing/quick or third-party library. Create chaos testing for concurrent posting scenarios. Set up performance benchmarks targeting P99 < 50ms for transaction posting. Create integration tests covering full end-to-end workflows. Add comprehensive error handling and logging. Document API usage with examples and common patterns.",
        "testStrategy": "Measure test coverage with go test -cover. Run property-based tests with large random datasets. Performance testing with concurrent goroutines simulating high load. Integration tests with full gRPC stack and database. Verify all acceptance criteria from PRD are met.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-26T09:18:15.624Z",
      "taskCount": 10,
      "completedCount": 1,
      "tags": [
        "4-financial-accounting"
      ],
      "created": "2025-10-27T10:13:36.410Z",
      "description": "Tasks for 4-financial-accounting context",
      "updated": "2025-10-27T10:13:36.410Z"
    }
  },
  "5-position-keeping": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Go project structure and dependencies",
        "description": "Set up the foundational Go project structure with modules, dependencies, and build configuration for the position-keeping service",
        "details": "Initialize go.mod with module name 'github.com/bjcoombs/meridian'. Create directory structure: cmd/, internal/position-keeping/{domain,repository,service}/, api/proto/position_keeping/v1/, pkg/, scripts/. Add core dependencies: gRPC (google.golang.org/grpc), Protocol Buffers (google.golang.org/protobuf), UUID library (github.com/google/uuid), database driver (github.com/lib/pq for PostgreSQL), testcontainers (github.com/testcontainers/testcontainers-go). Create Makefile for common tasks (build, test, generate protos). Set up .env.example for environment variables.",
        "testStrategy": "Verify go.mod is valid with 'go mod tidy'. Test that directory structure exists and is accessible. Verify all dependencies resolve correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize go.mod and create directory structure",
            "description": "Initialize the Go module and create the foundational directory structure for the position-keeping service",
            "dependencies": [],
            "details": "Run 'go mod init github.com/bjcoombs/meridian' to initialize the module. Create directory structure: cmd/, internal/position-keeping/domain/, internal/position-keeping/repository/, internal/position-keeping/service/, api/proto/position_keeping/v1/, pkg/, scripts/. Ensure all directories are created with proper permissions and structure follows Go project conventions.",
            "status": "pending",
            "testStrategy": "Verify go.mod file exists and contains correct module name. Check that all directories exist and are accessible. Run 'go mod tidy' to validate module structure."
          },
          {
            "id": 2,
            "title": "Add core dependencies and configure Makefile",
            "description": "Add all required Go dependencies and create a comprehensive Makefile for build automation",
            "dependencies": [
              1
            ],
            "details": "Add dependencies using go get: google.golang.org/grpc, google.golang.org/protobuf, github.com/google/uuid, github.com/lib/pq, github.com/testcontainers/testcontainers-go. Create Makefile with targets: build, test, clean, generate-protos, lint, docker-build. Include proper dependency management and build optimization flags.",
            "status": "pending",
            "testStrategy": "Run 'go mod tidy' to verify all dependencies resolve correctly. Test each Makefile target executes without errors. Verify 'make build' produces working binary."
          },
          {
            "id": 3,
            "title": "Create .env.example and verify project setup",
            "description": "Create environment variable template and perform comprehensive project setup verification",
            "dependencies": [
              2
            ],
            "details": "Create .env.example file with all required environment variables: DATABASE_URL, GRPC_PORT, LOG_LEVEL, REDIS_URL, METRICS_PORT, etc. Include comments explaining each variable's purpose and example values. Run comprehensive verification: go mod verify, make build, check all directories accessible, validate Makefile targets work correctly.",
            "status": "pending",
            "testStrategy": "Verify .env.example contains all necessary variables with clear documentation. Test that project builds successfully from clean state. Validate all Makefile targets execute properly. Confirm directory structure matches specifications."
          }
        ]
      },
      {
        "id": 2,
        "title": "Define gRPC protobuf contracts for Position Keeping service",
        "description": "Create comprehensive protobuf definitions for all Position Keeping service operations and events based on BIAN specification",
        "details": "Create api/proto/position_keeping/v1/position_keeping.proto with service definition including: InitiateFinancialPositionLog, InitiateFinancialPositionLogBatch, UpdateFinancialPositionLog, ControlFinancialPositionLog, RetrieveFinancialPositionLog, RetrieveFinancialPositionLogBatch. Define message types: FinancialPositionLog, Money, TransactionSource enum, PositionLogStatus enum, ReconciliationStatus enum. Create events.proto for domain events: TransactionCaptured, TransactionAmended, TransactionReconciled, TransactionPosted, TransactionRejected, BulkTransactionCaptured. Add buf.yaml configuration for protocol buffer management. Include validation rules using protoc-gen-validate.",
        "testStrategy": "Validate protobuf files compile without errors using protoc. Verify all required fields and enums are defined. Test generated Go code compiles.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create position_keeping.proto service definition with all operations",
            "description": "Create the main gRPC service definition file with all Position Keeping operations including InitiateFinancialPositionLog, InitiateFinancialPositionLogBatch, UpdateFinancialPositionLog, ControlFinancialPositionLog, RetrieveFinancialPositionLog, and RetrieveFinancialPositionLogBatch",
            "dependencies": [],
            "details": "Create api/proto/position_keeping/v1/position_keeping.proto file with PositionKeepingService definition containing all six required methods. Each method should have proper request/response message types with appropriate field definitions. Include proper package declaration, imports, and gRPC service options. Follow BIAN specification naming conventions and ensure all operations are properly documented with comments.",
            "status": "pending",
            "testStrategy": "Validate protobuf file compiles without errors using protoc. Test that all service methods are properly defined and accessible through grpcurl or similar tools."
          },
          {
            "id": 2,
            "title": "Define message types and enums for domain model",
            "description": "Define all required message types including FinancialPositionLog, Money, and enums for TransactionSource, PositionLogStatus, and ReconciliationStatus based on the domain requirements",
            "dependencies": [
              1
            ],
            "details": "Create comprehensive message definitions in position_keeping.proto including FinancialPositionLog with all necessary fields (transaction_reference, amount, accounts, dates, status fields), Money message with value/currency/decimal_places, TransactionSource enum (API, FILE, SYSTEM), PositionLogStatus enum (PENDING, POSTED, REJECTED), and ReconciliationStatus enum (UNRECONCILED, RECONCILED, DISPUTED). Include proper field numbering, validation annotations using protoc-gen-validate, and comprehensive field documentation.",
            "status": "pending",
            "testStrategy": "Verify all message types compile correctly and generated Go structs contain expected fields. Test enum value assignments and ensure validation rules work properly with protoc-gen-validate."
          },
          {
            "id": 3,
            "title": "Create events.proto and configure buf.yaml with validation",
            "description": "Create domain events protobuf file and configure buf.yaml for protocol buffer management with validation rules",
            "dependencies": [
              2
            ],
            "details": "Create api/proto/position_keeping/v1/events.proto containing domain event definitions: TransactionCaptured, TransactionAmended, TransactionReconciled, TransactionPosted, TransactionRejected, BulkTransactionCaptured events with proper event metadata and payload structures. Configure buf.yaml in project root with proper module configuration, dependencies, linting rules, and breaking change detection. Add protoc-gen-validate configuration for field validation rules across all message types.",
            "status": "pending",
            "testStrategy": "Test buf lint passes without errors on all protobuf files. Verify buf generate produces valid Go code. Test that domain events compile and contain proper event structure with timestamps and correlation IDs."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement core domain model with FinancialPositionLog aggregate",
        "description": "Create the FinancialPositionLog domain entity with all business rules, invariants, and methods for state transitions",
        "details": "Implement internal/position-keeping/domain/financial_position_log.go with struct containing: ID (uuid.UUID), TransactionReference (string), TransactionSource (enum), TransactionType (string), Amount (Money struct), SourceAccount/DestinationAccount (string), TransactionDate (time.Time), Status (enum), ReconciliationStatus (enum), PostedLedgerReference (*uuid.UUID), Metadata (map[string]interface{}), IdempotencyKey (string), CreatedAt/UpdatedAt (time.Time). Implement methods: MarkReconciled(), MarkPosted(), Reject(), Amend(), CanBeAmended(). Create Money value object with currency and decimal precision. Define enums for TransactionSource, PositionLogStatus, ReconciliationStatus. Implement state machine validation for status transitions.",
        "testStrategy": "Unit tests for all domain methods covering valid/invalid state transitions. Test invariant enforcement (amount > 0, unique transaction reference). Test Money value object operations. Verify state machine prevents invalid transitions.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement FinancialPositionLog struct and Money value object",
            "description": "Create the core domain structs including FinancialPositionLog with all required fields and the Money value object with currency and decimal precision support",
            "dependencies": [],
            "details": "Implement internal/position-keeping/domain/financial_position_log.go with FinancialPositionLog struct containing ID (uuid.UUID), TransactionReference (string), TransactionSource (enum), TransactionType (string), Amount (Money struct), SourceAccount/DestinationAccount (string), TransactionDate (time.Time), Status (enum), ReconciliationStatus (enum), PostedLedgerReference (*uuid.UUID), Metadata (map[string]interface{}), IdempotencyKey (string), CreatedAt/UpdatedAt (time.Time). Create Money value object with currency field and decimal.Decimal for precise monetary calculations.",
            "status": "pending",
            "testStrategy": "Unit tests for struct initialization, field validation, and Money value object operations including currency conversion and precision handling"
          },
          {
            "id": 2,
            "title": "Create enums and status transition state machine",
            "description": "Define all required enums and implement the state machine logic for valid status transitions with business rule enforcement",
            "dependencies": [
              1
            ],
            "details": "Define enums for TransactionSource (API, File, Manual), PositionLogStatus (Pending, Posted, Rejected, Amended), ReconciliationStatus (Unreconciled, Reconciled, Failed). Implement state machine validation ensuring valid transitions: Pending->Posted/Rejected/Amended, Posted->Reconciled, etc. Add validation functions to prevent invalid state changes and enforce business invariants.",
            "status": "pending",
            "testStrategy": "Unit tests covering all valid state transitions and verification that invalid transitions are properly rejected with appropriate error messages"
          },
          {
            "id": 3,
            "title": "Implement business methods with invariant validation",
            "description": "Create all business methods on FinancialPositionLog with proper invariant checking and business rule enforcement",
            "dependencies": [
              2
            ],
            "details": "Implement methods: MarkReconciled() with status validation, MarkPosted() with ledger reference assignment, Reject() with reason tracking, Amend() with audit trail, CanBeAmended() with business rule checking. Add invariant validation: amount must be > 0, transaction reference must be unique, status transitions must follow state machine rules. Include proper error handling and validation messages.",
            "status": "pending",
            "testStrategy": "Unit tests for each business method covering valid operations, invariant violations, and edge cases. Test concurrent access scenarios and validation error conditions"
          },
          {
            "id": 4,
            "title": "Add comprehensive unit tests for domain logic",
            "description": "Create complete test suite covering all domain logic, business rules, state transitions, and edge cases for the FinancialPositionLog aggregate",
            "dependencies": [
              3
            ],
            "details": "Create comprehensive test suite in financial_position_log_test.go covering: struct creation and validation, Money value object operations, enum validation, state machine transitions (valid and invalid), business method behavior, invariant enforcement, concurrent access scenarios, and edge cases. Use table-driven tests for state transitions and property-based testing for invariants where applicable.",
            "status": "pending",
            "testStrategy": "Achieve 100% test coverage for domain logic with focus on business rule validation, state machine correctness, and invariant enforcement. Include benchmark tests for performance-critical operations"
          }
        ]
      },
      {
        "id": 4,
        "title": "Create database schema and migration scripts",
        "description": "Design and implement PostgreSQL database schema for financial position logs with proper indexing and audit trail",
        "details": "Create migrations/ directory with numbered SQL files. Implement financial_position_logs table with columns: id (UUID PK), transaction_reference (TEXT), transaction_source (TEXT), transaction_type (TEXT), amount_value (BIGINT), amount_currency (CHAR(3)), amount_decimal_places (INT), source_account (TEXT), destination_account (TEXT), transaction_date (TIMESTAMPTZ), status (TEXT), reconciliation_status (TEXT), posted_ledger_reference (UUID), metadata (JSONB), idempotency_key (TEXT UNIQUE), created_at/updated_at (TIMESTAMPTZ). Add constraints: amount_value > 0, status/reconciliation_status CHECK constraints. Create indexes on status, transaction_reference, idempotency_key, transaction_date, reconciliation_status. Implement financial_position_log_audit table for audit trail. Create migration tooling using golang-migrate or similar.",
        "testStrategy": "Test migrations run successfully on clean database. Verify all indexes are created. Test constraint enforcement prevents invalid data. Verify audit trail triggers work correctly.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design financial_position_logs table schema with constraints",
            "description": "Create the main financial_position_logs table with all required columns, data types, primary key, and business constraints",
            "dependencies": [],
            "details": "Define table schema with columns: id (UUID PK), transaction_reference (TEXT), transaction_source (TEXT), transaction_type (TEXT), amount_value (BIGINT), amount_currency (CHAR(3)), amount_decimal_places (INT), source_account (TEXT), destination_account (TEXT), transaction_date (TIMESTAMPTZ), status (TEXT), reconciliation_status (TEXT), posted_ledger_reference (UUID), metadata (JSONB), idempotency_key (TEXT UNIQUE), created_at/updated_at (TIMESTAMPTZ). Add constraints: amount_value > 0, status CHECK (status IN ('pending', 'processed', 'failed')), reconciliation_status CHECK (reconciliation_status IN ('unreconciled', 'reconciled', 'disputed'))",
            "status": "pending",
            "testStrategy": "Test table creation SQL runs without errors. Verify constraints prevent invalid data insertion. Test unique constraint on idempotency_key works correctly."
          },
          {
            "id": 2,
            "title": "Create audit trail table and indexes",
            "description": "Implement financial_position_log_audit table for tracking changes and create performance indexes on both tables",
            "dependencies": [
              1
            ],
            "details": "Create financial_position_log_audit table with columns: audit_id (UUID PK), financial_position_log_id (UUID FK), operation_type (TEXT), old_values (JSONB), new_values (JSONB), changed_by (TEXT), changed_at (TIMESTAMPTZ). Create indexes on main table: idx_fpl_status ON status, idx_fpl_transaction_ref ON transaction_reference, idx_fpl_idempotency ON idempotency_key, idx_fpl_transaction_date ON transaction_date, idx_fpl_reconciliation_status ON reconciliation_status. Create audit table indexes: idx_audit_fpl_id ON financial_position_log_id, idx_audit_changed_at ON changed_at",
            "status": "pending",
            "testStrategy": "Verify audit table creation and foreign key constraints. Test index creation improves query performance. Verify audit triggers capture changes correctly."
          },
          {
            "id": 3,
            "title": "Implement migration tooling and scripts",
            "description": "Set up golang-migrate or similar migration framework with numbered migration files and migration management scripts",
            "dependencies": [],
            "details": "Create migrations/ directory structure. Install and configure golang-migrate tool. Create numbered migration files: 001_create_financial_position_logs.up.sql, 001_create_financial_position_logs.down.sql, 002_create_audit_table.up.sql, 002_create_audit_table.down.sql, 003_create_indexes.up.sql, 003_create_indexes.down.sql. Create migration scripts: scripts/migrate-up.sh, scripts/migrate-down.sh, scripts/migrate-reset.sh. Configure database connection parameters and migration source path",
            "status": "pending",
            "testStrategy": "Test migration up/down scripts work correctly. Verify migrations can be run multiple times safely. Test rollback functionality works as expected."
          },
          {
            "id": 4,
            "title": "Test migrations and constraint enforcement",
            "description": "Validate complete migration process and verify all database constraints work as designed",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Run complete migration suite on clean test database. Test constraint enforcement by attempting to insert invalid data (negative amounts, invalid status values, duplicate idempotency keys). Verify foreign key constraints work between main and audit tables. Test index performance with sample data. Verify audit triggers fire on INSERT/UPDATE/DELETE operations. Test migration rollback scenarios and verify data integrity",
            "status": "pending",
            "testStrategy": "Create automated test suite that runs migrations on fresh database instance. Test all constraint violations throw appropriate errors. Verify audit trail captures all changes. Performance test queries use indexes correctly."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement repository layer with PostgreSQL persistence",
        "description": "Create repository interface and PostgreSQL implementation for FinancialPositionLog persistence with full CRUD operations",
        "details": "Define FinancialPositionLogRepository interface in internal/position-keeping/domain/ with methods: Create(), CreateBatch(), FindByID(), FindByIdempotencyKey(), FindByTransactionReference(), Update(), List(), FindPendingForReconciliation(). Implement PostgreSQL repository in internal/position-keeping/repository/position_log_repository.go using database/sql or sqlx. Implement efficient bulk insert for CreateBatch() using COPY or prepared statements. Add connection pooling configuration. Implement proper error handling with custom error types. Add database transaction support for atomic operations. Include pagination support in List() method with PositionLogFilter struct.",
        "testStrategy": "Integration tests using testcontainers with real PostgreSQL instance. Test all CRUD operations, bulk operations, and filter queries. Test concurrent access scenarios. Verify idempotency key uniqueness enforcement. Test database transaction rollback scenarios.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define repository interface and error types",
            "description": "Create FinancialPositionLogRepository interface in domain package with all required methods and define custom error types for database operations",
            "dependencies": [],
            "details": "Define FinancialPositionLogRepository interface in internal/position-keeping/domain/ with methods: Create(), CreateBatch(), FindByID(), FindByIdempotencyKey(), FindByTransactionReference(), Update(), List(), FindPendingForReconciliation(). Create custom error types: ErrPositionLogNotFound, ErrDuplicateIdempotencyKey, ErrInvalidTransactionReference. Define PositionLogFilter struct for List() method with fields for filtering by status, date range, transaction type, and reconciliation status.",
            "status": "pending",
            "testStrategy": "Unit tests for interface validation and error type assertions. Mock implementations to verify interface contracts."
          },
          {
            "id": 2,
            "title": "Implement basic CRUD operations with connection pooling",
            "description": "Create PostgreSQL repository implementation with basic CRUD operations and proper connection pool configuration",
            "dependencies": [
              1
            ],
            "details": "Implement internal/position-keeping/repository/position_log_repository.go using sqlx for database operations. Configure connection pooling with appropriate max connections, idle connections, and connection lifetime settings. Implement Create(), FindByID(), FindByIdempotencyKey(), FindByTransactionReference(), and Update() methods with proper SQL queries. Add database schema migrations for financial_position_logs table with indexes on idempotency_key and transaction_reference.",
            "status": "pending",
            "testStrategy": "Integration tests using testcontainers with PostgreSQL. Test each CRUD operation independently. Verify connection pool behavior under load."
          },
          {
            "id": 3,
            "title": "Implement efficient bulk operations and transaction support",
            "description": "Add bulk insert capabilities and database transaction support for atomic operations",
            "dependencies": [
              2
            ],
            "details": "Implement CreateBatch() method using PostgreSQL COPY command or prepared statements for efficient bulk inserts. Add database transaction support with Begin(), Commit(), Rollback() operations. Implement transaction-aware repository methods that can operate within existing transactions. Handle partial batch failures with proper rollback mechanisms. Optimize bulk operations to handle up to 10,000 records efficiently with batching if needed.",
            "status": "pending",
            "testStrategy": "Test bulk insert performance with large datasets. Test transaction rollback scenarios. Verify atomic behavior of batch operations with deliberate failures."
          },
          {
            "id": 4,
            "title": "Add filtering and pagination for List operations",
            "description": "Implement comprehensive filtering and pagination support for the List method with performance optimization",
            "dependencies": [
              2
            ],
            "details": "Implement List() method with PositionLogFilter struct supporting filters by: status, date range, transaction type, reconciliation status, account references. Add pagination with limit/offset or cursor-based pagination. Implement FindPendingForReconciliation() method with optimized queries. Add proper indexing strategy for filter fields. Include sorting options by created date, transaction date, and amount.",
            "status": "pending",
            "testStrategy": "Test filtering with various combinations of filter criteria. Verify pagination performance with large datasets. Test edge cases like empty results and invalid filter parameters."
          },
          {
            "id": 5,
            "title": "Create comprehensive integration tests with testcontainers",
            "description": "Develop complete integration test suite using testcontainers to verify all repository functionality",
            "dependencies": [
              3,
              4
            ],
            "details": "Create integration test suite using testcontainers PostgreSQL module. Test all repository methods with real database operations. Include concurrent access scenarios to verify thread safety. Test idempotency key uniqueness enforcement at database level. Test connection pool behavior under high load. Add performance benchmarks for bulk operations. Test database migration scenarios and schema validation.",
            "status": "pending",
            "testStrategy": "Full integration test coverage for all repository methods. Concurrent testing with multiple goroutines. Performance benchmarks for bulk operations. Database failover and recovery testing."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement domain events and event publishing infrastructure",
        "description": "Create domain event system for position log lifecycle events with event publishing mechanism",
        "details": "Create internal/position-keeping/domain/events.go with event structs: TransactionCapturedEvent, TransactionAmendedEvent, TransactionReconciledEvent, TransactionPostedEvent, TransactionRejectedEvent, BulkTransactionCapturedEvent. Each event should contain: ID, AggregateID, EventType, Timestamp, Payload. Implement EventPublisher interface in pkg/platform/ for publishing events. Create in-memory implementation for testing and message broker implementation (NATS/RabbitMQ/Kafka). Add event versioning support. Implement event sourcing capability to rebuild aggregate state from events. Add event serialization/deserialization with JSON/protobuf. Create event middleware for correlation IDs and tracing.",
        "testStrategy": "Unit tests for event creation and serialization. Integration tests with message broker. Test event ordering and delivery guarantees. Verify event replay functionality works correctly.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create domain event structs and interfaces",
            "description": "Implement event structures and core interfaces for domain events in the position keeping system",
            "dependencies": [],
            "details": "Create internal/position-keeping/domain/events.go with domain event structs: TransactionCapturedEvent, TransactionAmendedEvent, TransactionReconciledEvent, TransactionPostedEvent, TransactionRejectedEvent, BulkTransactionCapturedEvent. Each event struct should contain standard fields: ID (uuid.UUID), AggregateID (uuid.UUID), EventType (string), Timestamp (time.Time), Payload (interface{}). Define DomainEvent interface with methods: GetID(), GetAggregateID(), GetEventType(), GetTimestamp(), GetPayload(). Add event versioning field (Version int) to support schema evolution.",
            "status": "pending",
            "testStrategy": "Unit tests for event struct creation, validation, and interface compliance. Test event field population and getter methods. Verify event type constants are correctly defined."
          },
          {
            "id": 2,
            "title": "Implement EventPublisher interface and in-memory implementation",
            "description": "Create event publishing interface and in-memory implementation for testing purposes",
            "dependencies": [
              1
            ],
            "details": "Define EventPublisher interface in pkg/platform/events/ with methods: Publish(event DomainEvent) error, PublishBatch(events []DomainEvent) error, Subscribe(eventType string, handler EventHandler) error. Implement InMemoryEventPublisher struct for testing with internal event storage using channels or slices. Add event handler registration and notification mechanism. Implement async publishing with goroutines and proper error handling. Add context support for cancellation and timeouts.",
            "status": "pending",
            "testStrategy": "Unit tests for in-memory publisher with event publishing, subscription, and handler invocation. Test concurrent publishing scenarios. Verify error handling and context cancellation behavior."
          },
          {
            "id": 3,
            "title": "Add message broker implementation with serialization",
            "description": "Implement message broker integration with event serialization capabilities",
            "dependencies": [
              2
            ],
            "details": "Create MessageBrokerEventPublisher implementation supporting NATS/RabbitMQ/Kafka integration. Implement event serialization/deserialization using JSON and protobuf formats. Add SerializationStrategy interface with JSONSerializer and ProtobufSerializer implementations. Configure message broker connection settings, topic/queue naming conventions, and retry mechanisms. Implement broker-specific error handling including connection failures and message delivery guarantees. Add configuration for different serialization formats based on event types.",
            "status": "pending",
            "testStrategy": "Integration tests with real message broker instances using testcontainers. Test JSON and protobuf serialization round-trip. Test connection failure scenarios and retry logic. Verify message delivery and ordering guarantees."
          },
          {
            "id": 4,
            "title": "Implement event sourcing and middleware with correlation IDs",
            "description": "Add event sourcing capability and middleware for correlation tracking",
            "dependencies": [
              3
            ],
            "details": "Implement EventStore interface with methods: SaveEvents(), LoadEvents(), GetEventsFromVersion() for event sourcing capability. Create event middleware for correlation ID injection using context.Context. Implement EventMiddleware interface with BeforePublish() and AfterPublish() hooks. Add CorrelationIDMiddleware to extract/inject correlation IDs from request context. Implement aggregate reconstruction from event streams with snapshotting support. Add distributed tracing integration with OpenTelemetry spans. Create event replay functionality for debugging and testing purposes.",
            "status": "pending",
            "testStrategy": "Unit tests for event store operations and aggregate reconstruction. Test correlation ID propagation through event pipeline. Test event replay functionality with various event sequences. Integration tests for distributed tracing integration."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement idempotency checking and duplicate prevention",
        "description": "Create robust idempotency mechanism to prevent duplicate transaction capture with concurrent request handling",
        "details": "Implement IdempotencyChecker interface in pkg/platform/ with methods: CheckKey(), StoreResult(), GetResult(). Create Redis-based implementation for distributed idempotency with TTL support. Implement database-based fallback using unique constraints. Add middleware for automatic idempotency handling in gRPC interceptors. Handle race conditions where multiple requests with same idempotency key arrive simultaneously. Implement idempotency for batch operations with partial success scenarios. Add configurable TTL for idempotency keys (24-48 hours). Create monitoring metrics for idempotency hit rates.",
        "testStrategy": "Concurrent test scenarios with multiple goroutines using same idempotency key. Test Redis failover scenarios. Verify partial batch success handling. Test TTL expiration behavior. Performance test with high concurrent load.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define IdempotencyChecker interface and basic implementation",
            "description": "Create the core IdempotencyChecker interface in pkg/platform/ with essential methods for idempotency management",
            "dependencies": [],
            "details": "Define IdempotencyChecker interface in pkg/platform/idempotency.go with methods: CheckKey(ctx context.Context, key string) (bool, error), StoreResult(ctx context.Context, key string, result interface{}) error, GetResult(ctx context.Context, key string) (interface{}, error). Create basic in-memory implementation for testing purposes with concurrent-safe map storage. Define IdempotencyResult struct to wrap stored results with metadata like creation time and expiry.",
            "status": "pending",
            "testStrategy": "Unit tests for interface methods with concurrent access scenarios. Test basic in-memory implementation thread safety using goroutines."
          },
          {
            "id": 2,
            "title": "Implement Redis-based distributed idempotency with TTL",
            "description": "Create Redis implementation of IdempotencyChecker for distributed idempotency with automatic expiration",
            "dependencies": [
              1
            ],
            "details": "Implement RedisIdempotencyChecker in pkg/platform/redis_idempotency.go using go-redis client. Implement CheckKey() using Redis EXISTS command, StoreResult() using SETEX with configurable TTL (24-48 hours), GetResult() using GET with JSON deserialization. Add connection pooling configuration and Redis cluster support. Implement proper error handling for Redis connection failures and timeouts. Add configuration struct for Redis connection details and TTL settings.",
            "status": "pending",
            "testStrategy": "Integration tests with Redis testcontainer. Test TTL expiration behavior. Test Redis connection failure scenarios and reconnection logic."
          },
          {
            "id": 3,
            "title": "Add database fallback and race condition handling",
            "description": "Implement database-based fallback mechanism and robust race condition handling for concurrent requests",
            "dependencies": [
              2
            ],
            "details": "Create database table 'idempotency_keys' with columns: key (VARCHAR PRIMARY KEY), result (JSONB), created_at (TIMESTAMP), expires_at (TIMESTAMP). Implement DatabaseIdempotencyChecker as fallback when Redis is unavailable. Add CompositeIdempotencyChecker that tries Redis first, falls back to database. Implement race condition handling using database unique constraints and proper error handling for duplicate key violations. Add cleanup job for expired database entries.",
            "status": "pending",
            "testStrategy": "Test Redis failover scenarios with database fallback. Concurrent tests with multiple goroutines using same idempotency key to verify race condition handling."
          },
          {
            "id": 4,
            "title": "Create gRPC middleware for automatic idempotency",
            "description": "Implement gRPC interceptors to automatically handle idempotency for all service methods",
            "dependencies": [
              3
            ],
            "details": "Create IdempotencyInterceptor in pkg/grpc/interceptors/idempotency.go for both unary and stream gRPC methods. Extract idempotency key from gRPC metadata header 'idempotency-key'. Implement unary interceptor that checks idempotency before method execution and stores result after successful completion. Add configuration for which methods require idempotency checking. Implement proper error serialization/deserialization for stored results. Add metrics for idempotency hit rates using Prometheus.",
            "status": "pending",
            "testStrategy": "Integration tests with gRPC test server. Test interceptor with various service methods. Verify idempotency headers are properly extracted and processed."
          },
          {
            "id": 5,
            "title": "Implement batch idempotency and comprehensive concurrent testing",
            "description": "Create idempotency handling for batch operations and comprehensive testing for concurrent scenarios",
            "dependencies": [
              4
            ],
            "details": "Implement BatchIdempotencyChecker with methods for handling partial batch success scenarios. Create batch idempotency keys using hash of all individual operation keys. Implement partial result storage where some operations succeed and others fail. Add comprehensive load testing with high concurrent requests using same idempotency keys. Create benchmark tests for Redis vs database performance. Implement monitoring dashboard for idempotency metrics including hit rates, cache misses, and performance metrics.",
            "status": "pending",
            "testStrategy": "Load tests with 1000+ concurrent requests using same idempotency key. Test partial batch failure scenarios. Performance benchmarks comparing Redis and database implementations."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement gRPC service layer with all BIAN operations",
        "description": "Create complete gRPC service implementation for Position Keeping with all required operations and proper error handling",
        "details": "Implement internal/position-keeping/service/position_keeping_service.go with struct containing repository, event publisher, and idempotency checker dependencies. Implement all gRPC methods: InitiateFinancialPositionLog() with validation, idempotency check, domain object creation, persistence, and event publishing. InitiateFinancialPositionLogBatch() with batch validation (max 10,000), parallel processing, atomic database transactions. UpdateFinancialPositionLog() with amendment logic and audit trail. ControlFinancialPositionLog() for status transitions. RetrieveFinancialPositionLog() and RetrieveFinancialPositionLogBatch() for queries. Add gRPC interceptors for logging, metrics, authentication, and error handling. Implement proper gRPC status codes and error messages. Add request/response validation using protobuf validation rules.",
        "testStrategy": "Integration tests for each gRPC method with test server. Test error conditions and validation failures. Test batch operations with large datasets. Test concurrent requests to same resources. Verify event publishing integration.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement basic gRPC service structure with dependency injection",
            "description": "Create the foundational gRPC service structure with proper dependency injection for repository, event publisher, and idempotency checker components",
            "dependencies": [],
            "details": "Create position_keeping_service.go with PositionKeepingService struct containing repository, eventPublisher, and idempotencyChecker fields. Implement constructor function NewPositionKeepingService() that accepts all dependencies. Set up proper interface definitions for clean dependency injection. Create service registration function for gRPC server integration. Ensure struct implements the generated protobuf service interface.",
            "status": "pending",
            "testStrategy": "Unit tests for service constructor and dependency injection. Verify all dependencies are properly set and accessible."
          },
          {
            "id": 2,
            "title": "Implement InitiateFinancialPositionLog with validation and idempotency",
            "description": "Implement the core InitiateFinancialPositionLog gRPC method with comprehensive validation, idempotency checking, and event publishing",
            "dependencies": [
              1
            ],
            "details": "Implement InitiateFinancialPositionLog() method with request validation using protobuf validation rules. Add idempotency key checking before processing. Create domain object from request data with proper validation. Persist entity using repository layer. Publish TransactionCaptured event on success. Handle all error cases with proper gRPC status codes. Add structured logging for audit trail.",
            "status": "pending",
            "testStrategy": "Integration tests with mock dependencies. Test validation failures, idempotency scenarios, and successful creation flow. Verify event publishing integration."
          },
          {
            "id": 3,
            "title": "Implement batch operations with atomic transactions",
            "description": "Implement InitiateFinancialPositionLogBatch with parallel processing, atomic database transactions, and proper error handling",
            "dependencies": [
              2
            ],
            "details": "Implement InitiateFinancialPositionLogBatch() with validation for maximum 10,000 items. Add parallel processing using goroutines with proper concurrency control. Implement atomic database transactions for batch operations. Handle partial success scenarios with detailed error reporting. Add batch idempotency checking. Implement efficient bulk insert operations. Add progress tracking and timeout handling.",
            "status": "pending",
            "testStrategy": "Test large batch operations with various sizes. Test partial failure scenarios and rollback behavior. Verify atomic transaction behavior and concurrent processing."
          },
          {
            "id": 4,
            "title": "Implement Update and Control operations with status transitions",
            "description": "Implement UpdateFinancialPositionLog and ControlFinancialPositionLog methods with proper state transitions and audit trail",
            "dependencies": [
              2
            ],
            "details": "Implement UpdateFinancialPositionLog() with amendment logic and audit trail creation. Add proper validation for update operations. Implement ControlFinancialPositionLog() for status transitions with business rule validation. Add RetrieveFinancialPositionLog() and RetrieveFinancialPositionLogBatch() for query operations. Ensure all operations maintain data consistency and proper error handling.",
            "status": "pending",
            "testStrategy": "Test all state transition scenarios. Verify audit trail creation. Test query operations with various filter combinations. Test invalid state transition prevention."
          },
          {
            "id": 5,
            "title": "Add gRPC interceptors and comprehensive integration tests",
            "description": "Implement gRPC interceptors for logging, metrics, authentication, and error handling, plus comprehensive integration test suite",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement logging interceptor with structured request/response logging. Add metrics interceptor for monitoring and observability. Create authentication interceptor for security. Implement error handling interceptor with proper gRPC status code mapping. Create comprehensive integration test suite testing all service methods with real dependencies. Add performance and load testing scenarios.",
            "status": "pending",
            "testStrategy": "Integration tests for each interceptor. End-to-end tests with full service stack. Performance tests with concurrent requests. Test authentication and authorization flows."
          }
        ]
      },
      {
        "id": 9,
        "title": "Create application configuration and dependency injection",
        "description": "Implement configuration management, dependency injection container, and application lifecycle management",
        "details": "Create internal/app/config.go with configuration structs for: database connection, gRPC server settings, event publishing, Redis connection, logging levels, metrics endpoints. Implement environment variable loading with validation and defaults. Create dependency injection container in internal/app/container.go using wire or manual DI. Implement application lifecycle with proper startup/shutdown sequences. Add health check endpoints for Kubernetes readiness/liveness probes. Implement graceful shutdown handling for gRPC server and database connections. Add structured logging with correlation IDs. Create metrics collection using Prometheus. Add OpenTelemetry tracing support.",
        "testStrategy": "Test configuration loading with various environment combinations. Test dependency injection resolves all dependencies correctly. Test graceful shutdown scenarios. Verify health checks respond appropriately.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create configuration structs and environment variable loading",
            "description": "Implement configuration management with structs for database, gRPC, Redis, and other service settings with environment variable loading and validation",
            "dependencies": [],
            "details": "Create internal/app/config.go with configuration structs for database connection (host, port, database name, credentials), gRPC server settings (port, TLS config), event publishing configuration, Redis connection parameters, logging levels, and metrics endpoints. Implement environment variable loading using viper or similar library with validation and sensible defaults. Add configuration validation to ensure required fields are present and values are valid (e.g., port ranges, connection strings).",
            "status": "pending",
            "testStrategy": "Test configuration loading with various environment variable combinations. Verify validation catches invalid configurations. Test default values are applied when environment variables are missing."
          },
          {
            "id": 2,
            "title": "Implement dependency injection container and validation",
            "description": "Create dependency injection container to manage service dependencies with proper initialization order and validation",
            "dependencies": [
              1
            ],
            "details": "Create internal/app/container.go implementing dependency injection container using wire code generation or manual DI pattern. Register all service dependencies including database connections, gRPC clients, Redis clients, logging infrastructure, and business services. Implement proper initialization order ensuring dependencies are created before dependent services. Add container validation to verify all required dependencies are registered and can be resolved.",
            "status": "pending",
            "testStrategy": "Test dependency injection resolves all dependencies correctly. Verify initialization order prevents circular dependencies. Test container validation catches missing dependencies."
          },
          {
            "id": 3,
            "title": "Add application lifecycle with graceful shutdown",
            "description": "Implement application startup and shutdown sequences with proper resource cleanup and signal handling",
            "dependencies": [
              2
            ],
            "details": "Create internal/app/app.go with Application struct managing lifecycle. Implement startup sequence initializing all services in correct order. Add graceful shutdown handling listening for SIGTERM and SIGINT signals. Implement shutdown sequence that stops accepting new requests, completes in-flight operations, closes database connections, and releases resources. Add configurable shutdown timeout to prevent hanging during deployment. Include context cancellation propagation to all running services.",
            "status": "pending",
            "testStrategy": "Test graceful shutdown scenarios with simulated traffic. Verify all resources are properly cleaned up. Test shutdown timeout prevents hanging processes."
          },
          {
            "id": 4,
            "title": "Implement health checks, metrics, and observability features",
            "description": "Add health check endpoints, Prometheus metrics collection, structured logging, and OpenTelemetry tracing support",
            "dependencies": [
              3
            ],
            "details": "Implement health check endpoints at /health/ready and /health/live for Kubernetes probes. Add dependency health checks for database, Redis, and external services. Implement Prometheus metrics collection for request counts, response times, error rates, and business metrics. Add structured logging with correlation IDs using logrus or zap. Integrate OpenTelemetry tracing with spans for gRPC calls, database operations, and business logic. Configure metrics and tracing exporters for monitoring infrastructure.",
            "status": "pending",
            "testStrategy": "Verify health checks respond appropriately when dependencies are healthy/unhealthy. Test metrics are collected and exposed correctly. Validate tracing spans are created for all operations."
          }
        ]
      },
      {
        "id": 10,
        "title": "Create comprehensive test suite and performance benchmarks",
        "description": "Implement complete test coverage including unit tests, integration tests, and performance benchmarks for all components",
        "details": "Create test/ directory with organized test suites. Implement unit tests for domain logic achieving >95% coverage. Create integration tests using testcontainers for repository layer with real PostgreSQL. Implement gRPC integration tests with test clients. Create end-to-end tests covering complete transaction lifecycle from capture to posting. Implement performance benchmarks for: single transaction capture (target: P99 < 20ms), bulk import (target: >10,000 txn/sec), concurrent idempotency checks, database query performance. Add test fixtures and factories for consistent test data. Create chaos testing scenarios for database failures, network partitions. Implement load testing with realistic transaction patterns. Add test coverage reporting and quality gates.",
        "testStrategy": "Run full test suite in CI/CD pipeline. Verify performance benchmarks meet targets. Test coverage reports show >95% for domain logic. Load tests demonstrate system handles target throughput. Chaos tests verify system resilience.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create unit test suite for domain logic with >95% coverage",
            "description": "Implement comprehensive unit tests for all domain entities, value objects, and business logic with coverage exceeding 95%",
            "dependencies": [],
            "details": "Create test/unit/ directory structure. Implement unit tests for FinancialPositionLog aggregate covering all methods: MarkReconciled(), UpdateStatus(), AddMetadata(). Test Money value object operations including currency validation and arithmetic. Test state machine transitions and invariant enforcement. Test transaction reference uniqueness validation. Add table-driven tests for edge cases. Use testify/assert for assertions. Configure go test coverage reporting with -coverprofile. Add coverage threshold checks to ensure >95% coverage for domain package.",
            "status": "pending",
            "testStrategy": "Run 'go test -coverprofile=coverage.out ./internal/position-keeping/domain/...' and verify coverage >95%. Test reports should show all domain logic paths covered."
          },
          {
            "id": 2,
            "title": "Implement repository integration tests with testcontainers",
            "description": "Create integration tests for the repository layer using testcontainers with real PostgreSQL instances",
            "dependencies": [
              1
            ],
            "details": "Create test/integration/ directory with PostgreSQL testcontainer setup. Implement repository integration tests covering: Insert(), FindByID(), FindByTransactionReference(), Update(), Delete() operations. Test transaction handling and rollback scenarios. Test concurrent access patterns and optimistic locking. Test database constraints and foreign key relationships. Test migration execution in test environment. Use testcontainers/postgres for isolated test databases. Add setup/teardown helpers for consistent test data. Test repository error handling for constraint violations.",
            "status": "pending",
            "testStrategy": "Integration tests must start fresh PostgreSQL container, run migrations, execute tests, and cleanup. Verify all repository methods work correctly with real database."
          },
          {
            "id": 3,
            "title": "Create gRPC service integration tests",
            "description": "Implement integration tests for gRPC services with test clients and service layer validation",
            "dependencies": [
              2
            ],
            "details": "Create test/grpc/ directory with gRPC test client setup. Implement tests for all service methods: CaptureTransaction(), GetTransactionStatus(), ListTransactions(), UpdateReconciliationStatus(). Test input validation and error responses. Test authentication and authorization if implemented. Test gRPC metadata handling and tracing headers. Create test fixtures for various transaction scenarios. Test streaming operations if implemented. Test service layer business logic integration with repository. Add gRPC reflection tests for API discoverability.",
            "status": "pending",
            "testStrategy": "Start gRPC server with test configuration, execute client tests against running server, verify all service endpoints respond correctly and handle errors appropriately."
          },
          {
            "id": 4,
            "title": "Implement end-to-end transaction lifecycle tests",
            "description": "Create comprehensive end-to-end tests covering complete transaction flow from capture to posting",
            "dependencies": [
              3
            ],
            "details": "Create test/e2e/ directory with full system test setup. Implement end-to-end scenarios: transaction capture → validation → persistence → reconciliation → posting. Test idempotency across the complete flow using duplicate transaction references. Test error handling and retry mechanisms. Test event publishing and consumption if applicable. Test audit trail creation throughout the lifecycle. Create realistic test data representing various transaction types. Test system behavior under normal and error conditions. Include database state verification at each lifecycle stage.",
            "status": "pending",
            "testStrategy": "Run complete system with all components, execute transaction lifecycle scenarios, verify final state matches expected outcomes and audit trail is complete."
          },
          {
            "id": 5,
            "title": "Create performance benchmarks and load testing",
            "description": "Implement performance benchmarks and load testing to meet specified performance targets",
            "dependencies": [
              4
            ],
            "details": "Create test/benchmark/ directory with Go benchmark tests. Implement benchmarks for: single transaction capture (target P99 < 20ms), bulk import operations (target >10,000 txn/sec), concurrent idempotency checks, database query performance. Use testing.B for Go benchmarks. Create load testing scenarios with realistic transaction patterns using tools like hey or vegeta. Test database connection pooling performance. Benchmark memory allocation and garbage collection impact. Create performance regression tests. Add CPU and memory profiling. Test system performance under various load conditions.",
            "status": "pending",
            "testStrategy": "Run benchmarks and verify P99 latency < 20ms for single transactions and throughput >10,000 txn/sec for bulk operations. Performance tests should demonstrate system meets all specified targets."
          },
          {
            "id": 6,
            "title": "Add chaos testing and test coverage reporting",
            "description": "Implement chaos testing scenarios and comprehensive test coverage reporting with quality gates",
            "dependencies": [
              5
            ],
            "details": "Create test/chaos/ directory with chaos engineering tests. Implement chaos scenarios: database connection failures, network partitions, service timeouts, resource exhaustion. Test system resilience and recovery mechanisms. Add circuit breaker testing. Test graceful degradation under various failure modes. Implement test coverage aggregation across unit, integration, and e2e tests. Create coverage reports in HTML and JSON formats. Add quality gates for minimum coverage thresholds. Integrate coverage reporting with CI/CD pipeline. Create test execution scripts that run all test suites and generate comprehensive reports.",
            "status": "pending",
            "testStrategy": "Chaos tests should verify system continues operating or fails gracefully under various failure scenarios. Coverage reports should show >95% overall coverage with detailed breakdown by package and test type."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-24T17:22:29.889Z",
      "updated": "2025-10-24T17:22:29.889Z",
      "description": "Tasks for position-keeping context",
      "renamed": {
        "from": "position-keeping",
        "date": "2025-10-24T17:40:23.968Z"
      }
    }
  },
  "6-current-account": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure and Go Module",
        "description": "Initialize Go module and create standard directory structure for CurrentAccount service following Go conventions",
        "details": "Create go.mod with module name 'github.com/bjcoombs/meridian' using Go 1.23+. Set up project directories: internal/current-account/{domain,repository,service}/, api/proto/current_account/v1/, cmd/, pkg/. Add core dependencies: google.golang.org/grpc, google.golang.org/protobuf, github.com/google/uuid, github.com/shopspring/decimal for precise financial calculations, github.com/lib/pq for PostgreSQL. Create .gitignore for Go projects excluding binaries, vendor/, and build artifacts.",
        "testStrategy": "Verify go.mod syntax with 'go mod tidy', confirm directory structure follows Go project layout standards, validate all dependencies resolve correctly with 'go build ./...'",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Current Account Domain Model",
        "description": "Create CurrentAccountFacility aggregate root and AccountTransaction entity with all business invariants and methods",
        "details": "Implement internal/current-account/domain/current_account_facility.go with struct containing: ID (UUID), AccountNumber (string, unique), CustomerReference (UUID), AccountCurrency (ISO-4217), AccountStatus (enum: active/frozen/closed), CurrentBalance/AvailableBalance (Money using shopspring/decimal), OverdraftLimit (Money), account dates, product/branch references. Add methods: Debit(), Credit(), CanDebit(), Freeze(), Unfreeze(), Close(), IsActive(). Create AccountTransaction entity with transaction details, status tracking, and idempotency support. Implement Money value object with currency validation and decimal arithmetic. Define enums for AccountStatus and TransactionType with proper validation.",
        "testStrategy": "Unit tests for all domain methods covering valid/invalid state transitions, overdraft enforcement, balance calculations, and currency validation. Property-based testing for arithmetic operations to ensure precision.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Database Schema and Migration System",
        "description": "Design PostgreSQL schema for current accounts and transactions with proper constraints and indexes",
        "details": "Create migrations/ directory with SQL files for current_account_facilities table (id UUID PK, account_number TEXT UNIQUE, customer_reference UUID, currency CHAR(3), status ENUM, balance fields as DECIMAL(19,4), overdraft_limit DECIMAL(19,4), dates) and account_transactions table (id UUID PK, account_id UUID FK, transaction_type ENUM, amount DECIMAL(19,4), running_balance DECIMAL(19,4), position_log_reference UUID, ledger_posting_reference UUID, idempotency_key TEXT UNIQUE). Add CHECK constraints for positive overdraft limits and valid status transitions. Create indexes on account_number, customer_reference, idempotency_key, transaction_date for performance.",
        "testStrategy": "Test migrations run successfully on clean database, verify all constraints prevent invalid data, validate indexes improve query performance with EXPLAIN ANALYZE, test referential integrity enforcement",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Repository Layer with PostgreSQL",
        "description": "Create repository interfaces and PostgreSQL implementations for account and transaction persistence",
        "details": "Define CurrentAccountRepository and AccountTransactionRepository interfaces in internal/current-account/domain/ with methods: Create(), FindByID(), FindByAccountNumber(), FindByCustomerReference(), Update(), List(). Implement PostgreSQL repositories in internal/current-account/repository/ using database/sql with prepared statements, connection pooling, and proper error handling. Include transaction management for atomic operations across account updates and transaction creation. Add optimistic locking for concurrent balance updates using version fields or timestamp comparison.",
        "testStrategy": "Integration tests using testcontainers with real PostgreSQL instance, test all CRUD operations, concurrent access scenarios, connection pooling under load, transaction rollback on errors, optimistic locking behavior",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Protocol Buffer Definitions",
        "description": "Define gRPC service contracts for CurrentAccount following BIAN specification",
        "details": "Create api/proto/current_account/v1/current_account.proto with CurrentAccountService including methods: InitiateCurrentAccount, UpdateCurrentAccount, ControlCurrentAccount (freeze/unfreeze/close), RetrieveCurrentAccount, DebitCurrentAccount, CreditCurrentAccount, RetrieveAccountTransactions. Define message types: CurrentAccountFacility, AccountTransaction, Money with proper field validation using protoc-gen-validate. Create events.proto for domain events: CurrentAccountInitiated, AccountDebited, AccountCredited, AccountFrozen, AccountClosed. Include proper gRPC method options for HTTP gateway mapping.",
        "testStrategy": "Validate protobuf compilation with protoc, verify generated Go code compiles correctly, test message serialization/deserialization, confirm validation rules work as expected",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement gRPC Service Layer",
        "description": "Create complete gRPC service implementation for CurrentAccount operations with proper business logic integration",
        "details": "Implement internal/current-account/service/current_account_service.go with struct containing repository dependencies, PositionKeeping client, FinancialAccounting client, event publisher, and idempotency checker. Implement DebitCurrentAccount method with full workflow: idempotency check, load account, validate active status, check sufficient funds (including overdraft), update balance atomically, create transaction record, call PositionKeeping service, publish domain event. Implement all other service methods following BIAN patterns. Add gRPC interceptors for authentication, logging, metrics, and error handling with proper status codes.",
        "testStrategy": "Integration tests for each gRPC method with test server, test error conditions and validation failures, test integration with PositionKeeping service, verify event publishing, test concurrent operations on same account",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Idempotency and Transaction Safety",
        "description": "Add Redis-based idempotency checking and distributed locking for safe concurrent operations",
        "details": "Create IdempotencyChecker interface in pkg/platform/ with Redis implementation for distributed idempotency using key format current-account:{operation}:{customer_key}. Implement distributed locking using Redis SETNX to prevent concurrent operations on same account. Add TTL management (24h default) for idempotency keys with automatic cleanup. Store operation results for duplicate request responses. Handle race conditions where multiple requests with same idempotency key arrive simultaneously. Include monitoring metrics for idempotency hit rates and lock contention.",
        "testStrategy": "Concurrent test scenarios with multiple goroutines operating on same account, test Redis failover scenarios, verify idempotency prevents duplicate transactions, test TTL expiration behavior, performance test under high concurrent load",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integration with PositionKeeping and FinancialAccounting",
        "description": "Implement service-to-service communication for transaction logging and ledger posting",
        "details": "Create gRPC clients for PositionKeeping and FinancialAccounting services. Implement transaction flow: CurrentAccount → PositionKeeping (transaction capture) → FinancialAccounting (ledger posting after reconciliation). Add circuit breaker pattern for external service calls with fallback behavior. Implement compensation patterns for failed downstream operations (saga pattern). Add retry logic with exponential backoff for transient failures. Include correlation ID propagation for distributed tracing across service boundaries.",
        "testStrategy": "Integration tests with mock PositionKeeping and FinancialAccounting services, test failure scenarios and compensation logic, verify circuit breaker behavior, test retry mechanisms, validate correlation ID propagation",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Add Observability and Health Monitoring",
        "description": "Implement comprehensive monitoring with metrics, tracing, logging, and health checks",
        "details": "Add OpenTelemetry instrumentation for distributed tracing across all service operations. Implement Prometheus metrics for business metrics (transaction rates, balance changes, overdraft usage) and technical metrics (response times, error rates, database connection health). Create structured JSON logging with correlation IDs using zerolog. Implement health check endpoints (/health/live, /health/ready) with dependency checking (database, Redis, external services). Add custom business metrics for regulatory reporting and SLA monitoring. Include log masking for sensitive financial data.",
        "testStrategy": "Verify metrics collection and export to Prometheus, validate trace propagation across service boundaries, test health endpoint responses under various dependency states, confirm sensitive data masking in logs, test correlation ID propagation",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Comprehensive Testing and Performance Validation",
        "description": "Create complete test suite with unit tests, integration tests, and performance benchmarks meeting acceptance criteria",
        "details": "Implement unit tests achieving >95% coverage for domain logic including edge cases, property-based testing for balance calculations, and boundary condition testing. Create integration tests using testcontainers for repository layer with real PostgreSQL. Implement end-to-end tests covering complete transaction lifecycle from initiation to posting. Add performance benchmarks targeting P99 < 30ms for account transactions and >1,000 TPS per account. Create load tests with realistic financial transaction patterns. Implement chaos testing for database failures and network partitions. Add compliance testing for BIAN specification adherence.",
        "testStrategy": "Achieve >95% test coverage for domain logic, verify performance targets are met (P99 < 30ms, >1,000 TPS), validate all BIAN operations work correctly, test system resilience under chaos scenarios, confirm acceptance criteria compliance",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-24T17:24:19.698Z",
      "updated": "2025-10-24T17:24:19.698Z",
      "description": "Tasks for current-account context",
      "renamed": {
        "from": "current-account",
        "date": "2025-10-24T17:40:24.991Z"
      }
    }
  }
}